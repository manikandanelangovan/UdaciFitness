["bc4788405a923ab33d436e521a93a473964ede3f","dba7dd4a9f3485ad2e73b8a60edeacea3cf5beb0",["EventEmitter","Image","NativeModules","React","prop-types","ReactNative","StaticContainer.react","StyleSheet","TVEventHandler","View","ViewPropTypes","create-react-class","fbjs/lib/invariant","requireNativeComponent","fbjs/lib/keyMirror"],[43,80,124,179,213,254,300,351,395,433,470,520,567,627,679],{"version":3,"sources":["/Users/mani/Documents/Udacity/Core/React_Native/UdaciFitness/node_modules/react-native/Libraries/Components/Navigation/NavigatorIOS.ios.js"],"names":["EventEmitter","require","Image","RCTNavigatorManager","NavigatorManager","React","PropTypes","ReactNative","StaticContainer","StyleSheet","TVEventHandler","View","ViewPropTypes","createReactClass","invariant","requireNativeComponent","keyMirror","TRANSITIONER_REF","__uid","getuid","NavigatorTransitionerIOS","cb","requestSchedulingJavaScriptNavigation","findNodeHandle","props","Component","SystemIconLabels","done","cancel","edit","save","add","compose","reply","action","organize","bookmarks","search","refresh","stop","camera","trash","play","pause","rewind","undo","redo","SystemIcons","NavigatorIOS","displayName","propTypes","initialRoute","shape","component","func","isRequired","title","string","titleImage","source","passProps","object","backButtonIcon","backButtonTitle","leftButtonIcon","leftButtonTitle","leftButtonSystemIcon","oneOf","Object","keys","onLeftButtonPress","rightButtonIcon","rightButtonTitle","rightButtonSystemIcon","onRightButtonPress","wrapperStyle","style","navigationBarHidden","bool","shadowHidden","tintColor","barTintColor","barStyle","titleTextColor","translucent","itemWrapperStyle","interactivePopGestureEnabled","navigator","undefined","componentWillMount","push","pop","popN","replace","replaceAtIndex","replacePrevious","replacePreviousAndPop","resetTo","popToRoute","popToTop","componentDidMount","_enableTVEventHandler","componentWillUnmount","_disableTVEventHandler","getDefaultProps","getInitialState","idStack","routeStack","requestedTopOfStack","observedTopOfStack","progress","fromIndex","toIndex","makingNavigatorRequest","updatingAllIndicesAtOrBeyond","_toFocusOnNavigationComplete","_handleFocusRequest","item","state","_getFocusEmitter","emit","_focusEmitter","focusEmitter","getChildContext","onFocusRequested","childContextTypes","instanceOf","_tryLockNavigator","refs","requestSchedulingNavigation","acquiredLock","_handleNavigatorStackChanged","e","newObservedTopOfStack","nativeEvent","stackLength","wasWaitingForConfirmation","nextState","setState","_eliminateUnneededChildren","length","slice","route","nextStack","concat","nextIDStack","n","newRequestedTopOfStack","index","nextRouteStack","indexOfRoute","indexOf","numToPop","_handleNavigationComplete","stopPropagation","_routeToStackItem","routeArg","i","shouldUpdateChild","styles","stackItem","_renderNavigationStackItems","shouldRecurseToNavigator","items","map","transitioner","vertical","_tvEventHandler","enable","cmp","evt","eventType","disable","render","create","backgroundColor","overflow","position","top","left","right","bottom","flex","RCTNavigator","RCTNavigatorItem","module","exports"],"mappings":"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","sourcesContent":["/**\n * Copyright (c) 2015-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule NavigatorIOS\n * @flow\n */\n'use strict';\n\nvar EventEmitter = require('EventEmitter');\nvar Image = require('Image');\nvar RCTNavigatorManager = require('NativeModules').NavigatorManager;\nvar React = require('React');\nvar PropTypes = require('prop-types');\nvar ReactNative = require('ReactNative');\nvar StaticContainer = require('StaticContainer.react');\nvar StyleSheet = require('StyleSheet');\nvar TVEventHandler = require('TVEventHandler');\nvar View = require('View');\nvar ViewPropTypes = require('ViewPropTypes');\n\nvar createReactClass = require('create-react-class');\nvar invariant = require('fbjs/lib/invariant');\nvar requireNativeComponent = require('requireNativeComponent');\n\nconst keyMirror = require('fbjs/lib/keyMirror');\n\nvar TRANSITIONER_REF = 'transitionerRef';\n\nvar __uid = 0;\nfunction getuid() {\n  return __uid++;\n}\n\nclass NavigatorTransitionerIOS extends React.Component<$FlowFixMeProps> {\n  requestSchedulingNavigation(cb) {\n    RCTNavigatorManager.requestSchedulingJavaScriptNavigation(\n      ReactNative.findNodeHandle(this),\n      cb\n    );\n  }\n\n  render() {\n    return (\n      <RCTNavigator {...this.props}/>\n    );\n  }\n}\n\nconst SystemIconLabels = {\n  done: true,\n  cancel: true,\n  edit: true,\n  save: true,\n  add: true,\n  compose: true,\n  reply: true,\n  action: true,\n  organize: true,\n  bookmarks: true,\n  search: true,\n  refresh: true,\n  stop: true,\n  camera: true,\n  trash: true,\n  play: true,\n  pause: true,\n  rewind: true,\n  'fast-forward': true,\n  undo: true,\n  redo: true,\n  'page-curl': true,\n};\nconst SystemIcons = keyMirror(SystemIconLabels);\n\ntype SystemButtonType = $Enum<typeof SystemIconLabels>;\n\ntype Route = {\n  component: Function,\n  title: string,\n  titleImage?: Object,\n  passProps?: Object,\n  backButtonTitle?: string,\n  backButtonIcon?: Object,\n  leftButtonTitle?: string,\n  leftButtonIcon?: Object,\n  leftButtonSystemIcon?: SystemButtonType,\n  onLeftButtonPress?: Function,\n  rightButtonTitle?: string,\n  rightButtonIcon?: Object,\n  rightButtonSystemIcon?: SystemButtonType,\n  onRightButtonPress?: Function,\n  wrapperStyle?: any,\n};\n\ntype State = {\n  idStack: Array<number>,\n  routeStack: Array<Route>,\n  requestedTopOfStack: number,\n  observedTopOfStack: number,\n  progress: number,\n  fromIndex: number,\n  toIndex: number,\n  makingNavigatorRequest: boolean,\n  updatingAllIndicesAtOrBeyond: ?number,\n}\n\ntype Event = Object;\n\n/**\n * Think of `<NavigatorIOS>` as simply a component that renders an\n * `RCTNavigator`, and moves the `RCTNavigator`'s `requestedTopOfStack` pointer\n * forward and backward. The `RCTNavigator` interprets changes in\n * `requestedTopOfStack` to be pushes and pops of children that are rendered.\n * `<NavigatorIOS>` always ensures that whenever the `requestedTopOfStack`\n * pointer is moved, that we've also rendered enough children so that the\n * `RCTNavigator` can carry out the push/pop with those children.\n * `<NavigatorIOS>` also removes children that will no longer be needed\n * (after the pop of a child has been fully completed/animated out).\n */\n\n/**\n * `NavigatorIOS` is a wrapper around\n * [`UINavigationController`](https://developer.apple.com/library/ios/documentation/UIKit/Reference/UINavigationController_Class/),\n * enabling you to implement a navigation stack. It works exactly the same as it\n * would on a native app using `UINavigationController`, providing the same\n * animations and behavior from UIKit.\n *\n * As the name implies, it is only available on iOS. Take a look at\n * [`React Navigation`](https://reactnavigation.org/) for a cross-platform\n * solution in JavaScript, or check out either of these components for native\n * solutions: [native-navigation](http://airbnb.io/native-navigation/),\n * [react-native-navigation](https://github.com/wix/react-native-navigation).\n *\n * To set up the navigator, provide the `initialRoute` prop with a route\n * object. A route object is used to describe each scene that your app\n * navigates to. `initialRoute` represents the first route in your navigator.\n *\n * ```\n * import PropTypes from 'prop-types';\n * import React, { Component } from 'react';\n * import { NavigatorIOS, Text } from 'react-native';\n *\n * export default class NavigatorIOSApp extends Component {\n *   render() {\n *     return (\n *       <NavigatorIOS\n *         initialRoute={{\n *           component: MyScene,\n *           title: 'My Initial Scene',\n *         }}\n *         style={{flex: 1}}\n *       />\n *     );\n *   }\n * }\n *\n * class MyScene extends Component {\n *   static propTypes = {\n *     title: PropTypes.string.isRequired,\n *     navigator: PropTypes.object.isRequired,\n *   }\n *\n *   _onForward = () => {\n *     this.props.navigator.push({\n *       title: 'Scene ' + nextIndex,\n *     });\n *   }\n *\n *   render() {\n *     return (\n *       <View>\n *         <Text>Current Scene: { this.props.title }</Text>\n *         <TouchableHighlight onPress={this._onForward}>\n *           <Text>Tap me to load the next scene</Text>\n *         </TouchableHighlight>\n *       </View>\n *     )\n *   }\n * }\n * ```\n *\n * In this code, the navigator renders the component specified in initialRoute,\n * which in this case is `MyScene`. This component will receive a `route` prop\n * and a `navigator` prop representing the navigator. The navigator's navigation\n * bar will render the title for the current scene, \"My Initial Scene\".\n *\n * You can optionally pass in a `passProps` property to your `initialRoute`.\n * `NavigatorIOS` passes this in as props to the rendered component:\n *\n * ```\n * initialRoute={{\n *   component: MyScene,\n *   title: 'My Initial Scene',\n *   passProps: { myProp: 'foo' }\n * }}\n * ```\n *\n * You can then access the props passed in via `{this.props.myProp}`.\n *\n * #### Handling Navigation\n *\n * To trigger navigation functionality such as pushing or popping a view, you\n * have access to a `navigator` object. The object is passed in as a prop to any\n * component that is rendered by `NavigatorIOS`. You can then call the\n * relevant methods to perform the navigation action you need:\n *\n * ```\n * class MyView extends Component {\n *   _handleBackPress() {\n *     this.props.navigator.pop();\n *   }\n *\n *   _handleNextPress(nextRoute) {\n *     this.props.navigator.push(nextRoute);\n *   }\n *\n *   render() {\n *     const nextRoute = {\n *       component: MyView,\n *       title: 'Bar That',\n *       passProps: { myProp: 'bar' }\n *     };\n *     return(\n *       <TouchableHighlight onPress={() => this._handleNextPress(nextRoute)}>\n *         <Text style={{marginTop: 200, alignSelf: 'center'}}>\n *           See you on the other nav {this.props.myProp}!\n *         </Text>\n *       </TouchableHighlight>\n *     );\n *   }\n * }\n * ```\n *\n * You can also trigger navigator functionality from the `NavigatorIOS`\n * component:\n *\n * ```\n * class NavvyIOS extends Component {\n *   _handleNavigationRequest() {\n *     this.refs.nav.push({\n *       component: MyView,\n *       title: 'Genius',\n *       passProps: { myProp: 'genius' },\n *     });\n *   }\n *\n *   render() {\n *     return (\n *       <NavigatorIOS\n *         ref='nav'\n *         initialRoute={{\n *           component: MyView,\n *           title: 'Foo This',\n *           passProps: { myProp: 'foo' },\n *           rightButtonTitle: 'Add',\n *           onRightButtonPress: () => this._handleNavigationRequest(),\n *         }}\n *         style={{flex: 1}}\n *       />\n *     );\n *   }\n * }\n * ```\n *\n * The code above adds a `_handleNavigationRequest` private method that is\n * invoked from the `NavigatorIOS` component when the right navigation bar item\n * is pressed. To get access to the navigator functionality, a reference to it\n * is saved in the `ref` prop and later referenced to push a new scene into the\n * navigation stack.\n *\n * #### Navigation Bar Configuration\n *\n * Props passed to `NavigatorIOS` will set the default configuration\n * for the navigation bar. Props passed as properties to a route object will set\n * the configuration for that route's navigation bar, overriding any props\n * passed to the `NavigatorIOS` component.\n *\n * ```\n * _handleNavigationRequest() {\n *   this.refs.nav.push({\n *     //...\n *     passProps: { myProp: 'genius' },\n *     barTintColor: '#996699',\n *   });\n * }\n *\n * render() {\n *   return (\n *     <NavigatorIOS\n *       //...\n *       style={{flex: 1}}\n *       barTintColor='#ffffcc'\n *     />\n *   );\n * }\n * ```\n *\n * In the example above the navigation bar color is changed when the new route\n * is pushed.\n *\n */\nvar NavigatorIOS = createReactClass({\n  displayName: 'NavigatorIOS',\n\n  propTypes: {\n\n    /**\n     * NavigatorIOS uses `route` objects to identify child views, their props,\n     * and navigation bar configuration. Navigation operations such as push\n     * operations expect routes to look like this the `initialRoute`.\n     */\n    initialRoute: PropTypes.shape({\n      /**\n       * The React Class to render for this route\n       */\n      component: PropTypes.func.isRequired,\n\n      /**\n       * The title displayed in the navigation bar and the back button for this\n       * route.\n       */\n      title: PropTypes.string.isRequired,\n\n      /**\n       * If set, a title image will appear instead of the text title.\n       */\n      titleImage: Image.propTypes.source,\n\n      /**\n       * Use this to specify additional props to pass to the rendered\n       * component. `NavigatorIOS` will automatically pass in `route` and\n       * `navigator` props to the comoponent.\n       */\n      passProps: PropTypes.object,\n\n      /**\n       * If set, the left navigation button image will be displayed using this\n       * source. Note that this doesn't apply to the header of the current\n       * view, but to those views that are subsequently pushed.\n       */\n      backButtonIcon: Image.propTypes.source,\n\n      /**\n       * If set, the left navigation button text will be set to this. Note that\n       * this doesn't apply to the left button of the current view, but to\n       * those views that are subsequently pushed\n       */\n      backButtonTitle: PropTypes.string,\n\n      /**\n       * If set, the left navigation button image will be displayed using\n       * this source.\n       */\n      leftButtonIcon: Image.propTypes.source,\n\n      /**\n       * If set, the left navigation button will display this text.\n       */\n      leftButtonTitle: PropTypes.string,\n\n      /**\n       * If set, the left header button will appear with this system icon\n       *\n       * Supported icons are `done`, `cancel`, `edit`, `save`, `add`,\n       * `compose`, `reply`, `action`, `organize`, `bookmarks`, `search`,\n       * `refresh`, `stop`, `camera`, `trash`, `play`, `pause`, `rewind`,\n       * `fast-forward`, `undo`, `redo`, and `page-curl`\n       */\n      leftButtonSystemIcon: PropTypes.oneOf(Object.keys(SystemIcons)),\n\n      /**\n       * This function will be invoked when the left navigation bar item is\n       * pressed.\n       */\n      onLeftButtonPress: PropTypes.func,\n\n      /**\n       * If set, the right navigation button image will be displayed using\n       * this source.\n       */\n      rightButtonIcon: Image.propTypes.source,\n\n      /**\n       * If set, the right navigation button will display this text.\n       */\n      rightButtonTitle: PropTypes.string,\n\n      /**\n       * If set, the right header button will appear with this system icon\n       *\n       * See leftButtonSystemIcon for supported icons\n       */\n      rightButtonSystemIcon: PropTypes.oneOf(Object.keys(SystemIcons)),\n\n      /**\n       * This function will be invoked when the right navigation bar item is\n       * pressed.\n       */\n      onRightButtonPress: PropTypes.func,\n\n      /**\n       * Styles for the navigation item containing the component.\n       */\n      wrapperStyle: ViewPropTypes.style,\n\n      /**\n       * Boolean value that indicates whether the navigation bar is hidden.\n       */\n      navigationBarHidden: PropTypes.bool,\n\n      /**\n       * Boolean value that indicates whether to hide the 1px hairline\n       * shadow.\n       */\n      shadowHidden: PropTypes.bool,\n\n      /**\n       * The color used for the buttons in the navigation bar.\n       */\n      tintColor: PropTypes.string,\n\n      /**\n       * The background color of the navigation bar.\n       */\n      barTintColor: PropTypes.string,\n\n      /**\n       * The style of the navigation bar. Supported values are 'default', 'black'.\n       * Use 'black' instead of setting `barTintColor` to black. This produces\n       * a navigation bar with the native iOS style with higher translucency.\n       */\n      barStyle: PropTypes.oneOf(['default', 'black']),\n\n       /**\n       * The text color of the navigation bar title.\n       */\n      titleTextColor: PropTypes.string,\n\n       /**\n       * Boolean value that indicates whether the navigation bar is\n       * translucent.\n       */\n      translucent: PropTypes.bool,\n\n    }).isRequired,\n\n    /**\n     * Boolean value that indicates whether the navigation bar is hidden\n     * by default.\n     */\n    navigationBarHidden: PropTypes.bool,\n\n    /**\n     * Boolean value that indicates whether to hide the 1px hairline shadow\n     * by default.\n     */\n    shadowHidden: PropTypes.bool,\n\n    /**\n     * The default wrapper style for components in the navigator.\n     * A common use case is to set the `backgroundColor` for every scene.\n     */\n    itemWrapperStyle: ViewPropTypes.style,\n\n    /**\n     * The default color used for the buttons in the navigation bar.\n     */\n    tintColor: PropTypes.string,\n\n    /**\n     * The default background color of the navigation bar.\n     */\n    barTintColor: PropTypes.string,\n\n    /**\n     * The style of the navigation bar. Supported values are 'default', 'black'.\n     * Use 'black' instead of setting `barTintColor` to black. This produces\n     * a navigation bar with the native iOS style with higher translucency.\n     */\n    barStyle: PropTypes.oneOf(['default', 'black']),\n\n    /**\n     * The default text color of the navigation bar title.\n     */\n    titleTextColor: PropTypes.string,\n\n    /**\n     * Boolean value that indicates whether the navigation bar is\n     * translucent by default\n     */\n    translucent: PropTypes.bool,\n\n    /**\n     * Boolean value that indicates whether the interactive pop gesture is\n     * enabled. This is useful for enabling/disabling the back swipe navigation\n     * gesture.\n     *\n     * If this prop is not provided, the default behavior is for the back swipe\n     * gesture to be enabled when the navigation bar is shown and disabled when\n     * the navigation bar is hidden. Once you've provided the\n     * `interactivePopGestureEnabled` prop, you can never restore the default\n     * behavior.\n     */\n    interactivePopGestureEnabled: PropTypes.bool,\n\n  },\n\n  navigator: (undefined: ?Object),\n\n  componentWillMount: function() {\n    // Precompute a pack of callbacks that's frequently generated and passed to\n    // instances.\n    this.navigator = {\n      push: this.push,\n      pop: this.pop,\n      popN: this.popN,\n      replace: this.replace,\n      replaceAtIndex: this.replaceAtIndex,\n      replacePrevious: this.replacePrevious,\n      replacePreviousAndPop: this.replacePreviousAndPop,\n      resetTo: this.resetTo,\n      popToRoute: this.popToRoute,\n      popToTop: this.popToTop,\n    };\n  },\n\n  componentDidMount: function() {\n    this._enableTVEventHandler();\n  },\n\n  componentWillUnmount: function() {\n    this._disableTVEventHandler();\n  },\n\n  getDefaultProps: function(): Object {\n    return {\n      translucent: true,\n    };\n  },\n\n  getInitialState: function(): State {\n    return {\n      idStack: [getuid()],\n      routeStack: [this.props.initialRoute],\n      // The navigation index that we wish to push/pop to.\n      requestedTopOfStack: 0,\n      // The last index that native has sent confirmation of completed push/pop\n      // for. At this point, we can discard any views that are beyond the\n      // `requestedTopOfStack`. A value of `null` means we have not received\n      // any confirmation, ever. We may receive an `observedTopOfStack` without\n      // ever requesting it - native can instigate pops of its own with the\n      // backswipe gesture.\n      observedTopOfStack: 0,\n      progress: 1,\n      fromIndex: 0,\n      toIndex: 0,\n      // Whether or not we are making a navigator request to push/pop. (Used\n      // for performance optimization).\n      makingNavigatorRequest: false,\n      // Whether or not we are updating children of navigator and if so (not\n      // `null`) which index marks the beginning of all updates. Used for\n      // performance optimization.\n      updatingAllIndicesAtOrBeyond: 0,\n    };\n  },\n\n  _toFocusOnNavigationComplete: (undefined: any),\n\n  _handleFocusRequest: function(item: any) {\n    if (this.state.makingNavigatorRequest) {\n      this._toFocusOnNavigationComplete = item;\n    } else {\n      this._getFocusEmitter().emit('focus', item);\n    }\n  },\n\n  _focusEmitter: (undefined: ?EventEmitter),\n\n  _getFocusEmitter: function(): EventEmitter {\n    // Flow not yet tracking assignments to instance fields.\n    var focusEmitter = this._focusEmitter;\n    if (!focusEmitter) {\n      focusEmitter = new EventEmitter();\n      this._focusEmitter = focusEmitter;\n    }\n    return focusEmitter;\n  },\n\n  getChildContext: function(): {\n    onFocusRequested: Function,\n    focusEmitter: EventEmitter,\n  } {\n    return {\n      onFocusRequested: this._handleFocusRequest,\n      focusEmitter: this._getFocusEmitter(),\n    };\n  },\n\n  childContextTypes: {\n    onFocusRequested: PropTypes.func,\n    focusEmitter: PropTypes.instanceOf(EventEmitter),\n  },\n\n  _tryLockNavigator: function(cb: () => void) {\n    this.refs[TRANSITIONER_REF].requestSchedulingNavigation(\n      (acquiredLock) => acquiredLock && cb()\n    );\n  },\n\n  _handleNavigatorStackChanged: function(e: Event) {\n    var newObservedTopOfStack = e.nativeEvent.stackLength - 1;\n\n    invariant(\n      newObservedTopOfStack <= this.state.requestedTopOfStack,\n      'No navigator item should be pushed without JS knowing about it %s %s', newObservedTopOfStack, this.state.requestedTopOfStack\n    );\n    var wasWaitingForConfirmation =\n      this.state.requestedTopOfStack !== this.state.observedTopOfStack;\n    if (wasWaitingForConfirmation) {\n      invariant(\n        newObservedTopOfStack === this.state.requestedTopOfStack,\n        'If waiting for observedTopOfStack to reach requestedTopOfStack, ' +\n        'the only valid observedTopOfStack should be requestedTopOfStack.'\n      );\n    }\n    // Mark the most recent observation regardless of if we can lock the\n    // navigator. `observedTopOfStack` merely represents what we've observed\n    // and this first `setState` is only executed to update debugging\n    // overlays/navigation bar.\n    // Also reset progress, toIndex, and fromIndex as they might not end\n    // in the correct states for a two possible reasons:\n    // Progress isn't always 0 or 1 at the end, the system rounds\n    // If the Navigator is offscreen these values won't be updated\n    // TOOD: Revisit this decision when no longer relying on native navigator.\n    var nextState = {\n      observedTopOfStack: newObservedTopOfStack,\n      makingNavigatorRequest: false,\n      updatingAllIndicesAtOrBeyond: null,\n      progress: 1,\n      toIndex: newObservedTopOfStack,\n      fromIndex: newObservedTopOfStack,\n    };\n    this.setState(nextState, this._eliminateUnneededChildren);\n  },\n\n  _eliminateUnneededChildren: function() {\n    // Updating the indices that we're deleting and that's all. (Truth: Nothing\n    // even uses the indices in this case, but let's make this describe the\n    // truth anyways).\n    var updatingAllIndicesAtOrBeyond =\n      this.state.routeStack.length > this.state.observedTopOfStack + 1 ?\n      this.state.observedTopOfStack + 1 :\n      null;\n    this.setState({\n      idStack: this.state.idStack.slice(0, this.state.observedTopOfStack + 1),\n      routeStack: this.state.routeStack.slice(0, this.state.observedTopOfStack + 1),\n      // Now we rerequest the top of stack that we observed.\n      requestedTopOfStack: this.state.observedTopOfStack,\n      makingNavigatorRequest: true,\n      updatingAllIndicesAtOrBeyond: updatingAllIndicesAtOrBeyond,\n    });\n  },\n\n  /**\n   * Navigate forward to a new route.\n   * @param route The new route to navigate to.\n   */\n  push: function(route: Route) {\n    invariant(!!route, 'Must supply route to push');\n    // Make sure all previous requests are caught up first. Otherwise reject.\n    if (this.state.requestedTopOfStack === this.state.observedTopOfStack) {\n      this._tryLockNavigator(() => {\n\n        var nextStack = this.state.routeStack.concat([route]);\n        var nextIDStack = this.state.idStack.concat([getuid()]);\n        this.setState({\n          // We have to make sure that we've also supplied enough views to\n          // satisfy our request to adjust the `requestedTopOfStack`.\n          idStack: nextIDStack,\n          routeStack: nextStack,\n          requestedTopOfStack: nextStack.length - 1,\n          makingNavigatorRequest: true,\n          updatingAllIndicesAtOrBeyond: nextStack.length - 1,\n        });\n      });\n    }\n  },\n\n  /**\n   * Go back N scenes at once. When N=1, behavior matches `pop()`.\n   * @param n The number of scenes to pop.\n   */\n  popN: function(n: number) {\n    if (n === 0) {\n      return;\n    }\n    // Make sure all previous requests are caught up first. Otherwise reject.\n    if (this.state.requestedTopOfStack === this.state.observedTopOfStack) {\n      if (this.state.requestedTopOfStack > 0) {\n        this._tryLockNavigator(() => {\n          var newRequestedTopOfStack = this.state.requestedTopOfStack - n;\n          invariant(newRequestedTopOfStack >= 0, 'Cannot pop below 0');\n          this.setState({\n            requestedTopOfStack: newRequestedTopOfStack,\n            makingNavigatorRequest: true,\n            updatingAllIndicesAtOrBeyond: this.state.requestedTopOfStack - n,\n          });\n        });\n      }\n    }\n  },\n\n  /**\n   * Pop back to the previous scene.\n   */\n  pop: function() {\n    this.popN(1);\n  },\n\n  /**\n   * Replace a route in the navigation stack.\n   *\n   * @param route The new route that will replace the specified one.\n   * @param index The route into the stack that should be replaced.\n   *    If it is negative, it counts from the back of the stack.\n   */\n  replaceAtIndex: function(route: Route, index: number) {\n    invariant(!!route, 'Must supply route to replace');\n    if (index < 0) {\n      index += this.state.routeStack.length;\n    }\n\n    if (this.state.routeStack.length <= index) {\n      return;\n    }\n\n    // I don't believe we need to lock for a replace since there's no\n    // navigation actually happening\n    var nextIDStack = this.state.idStack.slice();\n    var nextRouteStack = this.state.routeStack.slice();\n    nextIDStack[index] = getuid();\n    nextRouteStack[index] = route;\n\n    this.setState({\n      idStack: nextIDStack,\n      routeStack: nextRouteStack,\n      makingNavigatorRequest: false,\n      updatingAllIndicesAtOrBeyond: index,\n    });\n\n  },\n\n  /**\n   * Replace the route for the current scene and immediately\n   * load the view for the new route.\n   * @param route The new route to navigate to.\n   */\n  replace: function(route: Route) {\n    this.replaceAtIndex(route, -1);\n  },\n\n  /**\n   * Replace the route/view for the previous scene.\n   * @param route The new route to will replace the previous scene.\n   */\n  replacePrevious: function(route: Route) {\n    this.replaceAtIndex(route, -2);\n  },\n\n  /**\n   * Go back to the topmost item in the navigation stack.\n   */\n  popToTop: function() {\n    this.popToRoute(this.state.routeStack[0]);\n  },\n\n  /**\n   * Go back to the item for a particular route object.\n   * @param route The new route to navigate to.\n   */\n  popToRoute: function(route: Route) {\n    var indexOfRoute = this.state.routeStack.indexOf(route);\n    invariant(\n      indexOfRoute !== -1,\n      'Calling pop to route for a route that doesn\\'t exist!'\n    );\n    var numToPop = this.state.routeStack.length - indexOfRoute - 1;\n    this.popN(numToPop);\n  },\n\n  /**\n   * Replaces the previous route/view and transitions back to it.\n   * @param route The new route that replaces the previous scene.\n   */\n  replacePreviousAndPop: function(route: Route) {\n    // Make sure all previous requests are caught up first. Otherwise reject.\n    if (this.state.requestedTopOfStack !== this.state.observedTopOfStack) {\n      return;\n    }\n    if (this.state.routeStack.length < 2) {\n      return;\n    }\n    this._tryLockNavigator(() => {\n      this.replacePrevious(route);\n      this.setState({\n        requestedTopOfStack: this.state.requestedTopOfStack - 1,\n        makingNavigatorRequest: true,\n      });\n    });\n  },\n\n  /**\n   * Replaces the top item and pop to it.\n   * @param route The new route that will replace the topmost item.\n   */\n  resetTo: function(route: Route) {\n    invariant(!!route, 'Must supply route to push');\n    // Make sure all previous requests are caught up first. Otherwise reject.\n    if (this.state.requestedTopOfStack !== this.state.observedTopOfStack) {\n      return;\n    }\n    this.replaceAtIndex(route, 0);\n    this.popToRoute(route);\n  },\n\n  _handleNavigationComplete: function(e: Event) {\n    // Don't propagate to other NavigatorIOS instances this is nested in:\n    e.stopPropagation();\n\n    if (this._toFocusOnNavigationComplete) {\n      this._getFocusEmitter().emit('focus', this._toFocusOnNavigationComplete);\n      this._toFocusOnNavigationComplete = null;\n    }\n    this._handleNavigatorStackChanged(e);\n  },\n\n  _routeToStackItem: function(routeArg: Route, i: number) {\n    var {component, wrapperStyle, passProps, ...route} = routeArg;\n    var {itemWrapperStyle, ...props} = this.props;\n    var shouldUpdateChild =\n      this.state.updatingAllIndicesAtOrBeyond != null &&\n      this.state.updatingAllIndicesAtOrBeyond >= i;\n    var Component = component;\n    return (\n      <StaticContainer key={'nav' + i} shouldUpdate={shouldUpdateChild}>\n        <RCTNavigatorItem\n          {...props}\n          {...route}\n          style={[\n            styles.stackItem,\n            itemWrapperStyle,\n            wrapperStyle\n          ]}>\n          <Component\n            navigator={this.navigator}\n            route={route}\n            {...passProps}\n          />\n        </RCTNavigatorItem>\n      </StaticContainer>\n    );\n  },\n\n  _renderNavigationStackItems: function() {\n    var shouldRecurseToNavigator =\n      this.state.makingNavigatorRequest ||\n      this.state.updatingAllIndicesAtOrBeyond !== null;\n    // If not recursing update to navigator at all, may as well avoid\n    // computation of navigator children.\n    var items = shouldRecurseToNavigator ?\n      this.state.routeStack.map(this._routeToStackItem) : null;\n    return (\n      <StaticContainer shouldUpdate={shouldRecurseToNavigator}>\n        <NavigatorTransitionerIOS\n          ref={TRANSITIONER_REF}\n          style={styles.transitioner}\n          // $FlowFixMe(>=0.41.0)\n          vertical={this.props.vertical}\n          requestedTopOfStack={this.state.requestedTopOfStack}\n          onNavigationComplete={this._handleNavigationComplete}\n          interactivePopGestureEnabled={this.props.interactivePopGestureEnabled}>\n          {items}\n        </NavigatorTransitionerIOS>\n      </StaticContainer>\n    );\n  },\n\n  _tvEventHandler: (undefined: ?TVEventHandler),\n\n  _enableTVEventHandler: function() {\n    this._tvEventHandler = new TVEventHandler();\n    this._tvEventHandler.enable(this, function(cmp, evt) {\n      if (evt && evt.eventType === 'menu') {\n        cmp.pop();\n      }\n    });\n  },\n\n  _disableTVEventHandler: function() {\n    if (this._tvEventHandler) {\n      this._tvEventHandler.disable();\n      delete this._tvEventHandler;\n    }\n  },\n\n  render: function() {\n    return (\n      // $FlowFixMe(>=0.41.0)\n      <View style={this.props.style}>\n        {this._renderNavigationStackItems()}\n      </View>\n    );\n  },\n});\n\nvar styles = StyleSheet.create({\n  stackItem: {\n    backgroundColor: 'white',\n    overflow: 'hidden',\n    position: 'absolute',\n    top: 0,\n    left: 0,\n    right: 0,\n    bottom: 0,\n  },\n  transitioner: {\n    flex: 1,\n  },\n});\n\nvar RCTNavigator = requireNativeComponent('RCTNavigator');\nvar RCTNavigatorItem = requireNativeComponent('RCTNavItem');\n\nmodule.exports = NavigatorIOS;\n"]}]