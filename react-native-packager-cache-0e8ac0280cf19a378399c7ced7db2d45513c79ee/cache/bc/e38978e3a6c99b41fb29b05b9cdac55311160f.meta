["61c64a77b7cc644c2f80e23e70a994283c7ca51d","d7455fec741f4e3c4d5894665e1c69618a209a1b",["./EmitterSubscription","./EventSubscriptionVendor","fbjs/lib/emptyFunction","fbjs/lib/invariant"],[214,278,337,388],{"version":3,"sources":["/Users/mani/Documents/Udacity/Core/React_Native/UdaciFitness/node_modules/fbemitter/lib/BaseEventEmitter.js"],"names":["_classCallCheck","instance","Constructor","TypeError","EmitterSubscription","require","EventSubscriptionVendor","emptyFunction","invariant","BaseEventEmitter","_subscriber","_currentSubscription","prototype","addListener","eventType","listener","context","addSubscription","once","emitter","removeCurrentListener","apply","arguments","removeAllListeners","removeAllSubscriptions","process","env","NODE_ENV","undefined","removeSubscription","listeners","subscriptions","getSubscriptionsForType","filter","thatReturnsTrue","map","subscription","emit","keys","Object","ii","length","key","__emitToSubscription","concat","Array","slice","call","args","module","exports"],"mappings":"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","sourcesContent":["/**\n * Copyright (c) 2014-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule BaseEventEmitter\n * @typechecks\n */\n\n'use strict';\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }\n\nvar EmitterSubscription = require('./EmitterSubscription');\nvar EventSubscriptionVendor = require('./EventSubscriptionVendor');\n\nvar emptyFunction = require('fbjs/lib/emptyFunction');\nvar invariant = require('fbjs/lib/invariant');\n\n/**\n * @class BaseEventEmitter\n * @description\n * An EventEmitter is responsible for managing a set of listeners and publishing\n * events to them when it is told that such events happened. In addition to the\n * data for the given event it also sends a event control object which allows\n * the listeners/handlers to prevent the default behavior of the given event.\n *\n * The emitter is designed to be generic enough to support all the different\n * contexts in which one might want to emit events. It is a simple multicast\n * mechanism on top of which extra functionality can be composed. For example, a\n * more advanced emitter may use an EventHolder and EventFactory.\n */\n\nvar BaseEventEmitter = (function () {\n  /**\n   * @constructor\n   */\n\n  function BaseEventEmitter() {\n    _classCallCheck(this, BaseEventEmitter);\n\n    this._subscriber = new EventSubscriptionVendor();\n    this._currentSubscription = null;\n  }\n\n  /**\n   * Adds a listener to be invoked when events of the specified type are\n   * emitted. An optional calling context may be provided. The data arguments\n   * emitted will be passed to the listener function.\n   *\n   * TODO: Annotate the listener arg's type. This is tricky because listeners\n   *       can be invoked with varargs.\n   *\n   * @param {string} eventType - Name of the event to listen to\n   * @param {function} listener - Function to invoke when the specified event is\n   *   emitted\n   * @param {*} context - Optional context object to use when invoking the\n   *   listener\n   */\n\n  BaseEventEmitter.prototype.addListener = function addListener(eventType, listener, context) {\n    return this._subscriber.addSubscription(eventType, new EmitterSubscription(this._subscriber, listener, context));\n  };\n\n  /**\n   * Similar to addListener, except that the listener is removed after it is\n   * invoked once.\n   *\n   * @param {string} eventType - Name of the event to listen to\n   * @param {function} listener - Function to invoke only once when the\n   *   specified event is emitted\n   * @param {*} context - Optional context object to use when invoking the\n   *   listener\n   */\n\n  BaseEventEmitter.prototype.once = function once(eventType, listener, context) {\n    var emitter = this;\n    return this.addListener(eventType, function () {\n      emitter.removeCurrentListener();\n      listener.apply(context, arguments);\n    });\n  };\n\n  /**\n   * Removes all of the registered listeners, including those registered as\n   * listener maps.\n   *\n   * @param {?string} eventType - Optional name of the event whose registered\n   *   listeners to remove\n   */\n\n  BaseEventEmitter.prototype.removeAllListeners = function removeAllListeners(eventType) {\n    this._subscriber.removeAllSubscriptions(eventType);\n  };\n\n  /**\n   * Provides an API that can be called during an eventing cycle to remove the\n   * last listener that was invoked. This allows a developer to provide an event\n   * object that can remove the listener (or listener map) during the\n   * invocation.\n   *\n   * If it is called when not inside of an emitting cycle it will throw.\n   *\n   * @throws {Error} When called not during an eventing cycle\n   *\n   * @example\n   *   var subscription = emitter.addListenerMap({\n   *     someEvent: function(data, event) {\n   *       console.log(data);\n   *       emitter.removeCurrentListener();\n   *     }\n   *   });\n   *\n   *   emitter.emit('someEvent', 'abc'); // logs 'abc'\n   *   emitter.emit('someEvent', 'def'); // does not log anything\n   */\n\n  BaseEventEmitter.prototype.removeCurrentListener = function removeCurrentListener() {\n    !!!this._currentSubscription ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Not in an emitting cycle; there is no current subscription') : invariant(false) : undefined;\n    this._subscriber.removeSubscription(this._currentSubscription);\n  };\n\n  /**\n   * Returns an array of listeners that are currently registered for the given\n   * event.\n   *\n   * @param {string} eventType - Name of the event to query\n   * @return {array}\n   */\n\n  BaseEventEmitter.prototype.listeners = function listeners(eventType) /* TODO: Array<EventSubscription> */{\n    var subscriptions = this._subscriber.getSubscriptionsForType(eventType);\n    return subscriptions ? subscriptions.filter(emptyFunction.thatReturnsTrue).map(function (subscription) {\n      return subscription.listener;\n    }) : [];\n  };\n\n  /**\n   * Emits an event of the given type with the given data. All handlers of that\n   * particular type will be notified.\n   *\n   * @param {string} eventType - Name of the event to emit\n   * @param {*} Arbitrary arguments to be passed to each registered listener\n   *\n   * @example\n   *   emitter.addListener('someEvent', function(message) {\n   *     console.log(message);\n   *   });\n   *\n   *   emitter.emit('someEvent', 'abc'); // logs 'abc'\n   */\n\n  BaseEventEmitter.prototype.emit = function emit(eventType) {\n    var subscriptions = this._subscriber.getSubscriptionsForType(eventType);\n    if (subscriptions) {\n      var keys = Object.keys(subscriptions);\n      for (var ii = 0; ii < keys.length; ii++) {\n        var key = keys[ii];\n        var subscription = subscriptions[key];\n        // The subscription may have been removed during this event loop.\n        if (subscription) {\n          this._currentSubscription = subscription;\n          this.__emitToSubscription.apply(this, [subscription].concat(Array.prototype.slice.call(arguments)));\n        }\n      }\n      this._currentSubscription = null;\n    }\n  };\n\n  /**\n   * Provides a hook to override how the emitter emits an event to a specific\n   * subscription. This allows you to set up logging and error boundaries\n   * specific to your environment.\n   *\n   * @param {EmitterSubscription} subscription\n   * @param {string} eventType\n   * @param {*} Arbitrary arguments to be passed to each registered listener\n   */\n\n  BaseEventEmitter.prototype.__emitToSubscription = function __emitToSubscription(subscription, eventType) {\n    var args = Array.prototype.slice.call(arguments, 2);\n    subscription.listener.apply(subscription.context, args);\n  };\n\n  return BaseEventEmitter;\n})();\n\nmodule.exports = BaseEventEmitter;"]}]