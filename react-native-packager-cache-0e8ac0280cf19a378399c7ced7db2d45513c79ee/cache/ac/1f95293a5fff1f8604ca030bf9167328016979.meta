["be093c9763d1d93d176dfcb24915f327297959e4","a93dd96511e37242a3b722f3d842dc49d21a3a52",["EdgeInsetsPropType","PlatformViewPropTypes","prop-types","StyleSheetPropType","ViewStylePropTypes","ViewAccessibility"],[49,108,158,206,262,309],{"version":3,"sources":["/Users/mani/Documents/Udacity/Core/React_Native/UdaciFitness/node_modules/react-native/Libraries/Components/View/ViewPropTypes.js"],"names":["EdgeInsetsPropType","require","PlatformViewPropTypes","PropTypes","StyleSheetPropType","ViewStylePropTypes","AccessibilityComponentTypes","AccessibilityTraits","stylePropType","module","exports","accessible","bool","accessibilityLabel","node","accessibilityComponentType","oneOf","accessibilityLiveRegion","importantForAccessibility","accessibilityTraits","oneOfType","arrayOf","accessibilityViewIsModal","onAccessibilityTap","func","onMagicTap","testID","string","nativeID","onResponderGrant","onResponderMove","onResponderReject","onResponderRelease","onResponderTerminate","onResponderTerminationRequest","onStartShouldSetResponder","onStartShouldSetResponderCapture","onMoveShouldSetResponder","onMoveShouldSetResponderCapture","hitSlop","onLayout","pointerEvents","style","removeClippedSubviews","renderToHardwareTextureAndroid","shouldRasterizeIOS","collapsable","needsOffscreenAlphaCompositing"],"mappings":";AAWA;;AAEA,IAAMA,qBAAqBC,OAArB,sBAAN;AACA,IAAMC,wBAAwBD,OAAxB,yBAAN;AACA,IAAME,YAAYF,OAAZ,cAAN;AACA,IAAMG,qBAAqBH,OAArB,sBAAN;AACA,IAAMI,qBAAqBJ,OAArB,sBAAN;;eAKIA,O;IAFFK,2B,YAAAA,2B;IACAC,mB,YAAAA,mB;;AAUF,IAAMC,gBAAgBJ,mBAAmBC,kBAAnB,CAAtB;;AAkDAI,OAAOC,OAAP,4BACKR,qBADL;AAOES,cAAYR,UAAUS,IAPxB;;AAcEC,sBAAoBV,UAAUW,IAdhC;;AA6BEC,8BAA4BZ,UAAUa,KAAV,CAAgBV,2BAAhB,CA7B9B;;AA6CEW,2BAAyBd,UAAUa,KAAV,CAAgB,CACvC,MADuC,EAEvC,QAFuC,EAGvC,WAHuC,CAAhB,CA7C3B;;AAsEEE,6BAA2Bf,UAAUa,KAAV,CAAgB,CACzC,MADyC,EAEzC,KAFyC,EAGzC,IAHyC,EAIzC,qBAJyC,CAAhB,CAtE7B;;AA4GEG,uBAAqBhB,UAAUiB,SAAV,CAAoB,CACvCjB,UAAUa,KAAV,CAAgBT,mBAAhB,CADuC,EAEvCJ,UAAUkB,OAAV,CAAkBlB,UAAUa,KAAV,CAAgBT,mBAAhB,CAAlB,CAFuC,CAApB,CA5GvB;;AA2HEe,4BAA0BnB,UAAUS,IA3HtC;;AAiIEW,sBAAoBpB,UAAUqB,IAjIhC;;AAuIEC,cAAYtB,UAAUqB,IAvIxB;;AA8IEE,UAAQvB,UAAUwB,MA9IpB;;AAqJEC,YAAUzB,UAAUwB,MArJtB;;AAoKEE,oBAAkB1B,UAAUqB,IApK9B;;AA4KEM,mBAAiB3B,UAAUqB,IA5K7B;;AAqLEO,qBAAmB5B,UAAUqB,IArL/B;;AA6LEQ,sBAAoB7B,UAAUqB,IA7LhC;;AAuMES,wBAAsB9B,UAAUqB,IAvMlC;;AAgNEU,iCAA+B/B,UAAUqB,IAhN3C;;AAwNEW,6BAA2BhC,UAAUqB,IAxNvC;;AAiOEY,oCAAkCjC,UAAUqB,IAjO9C;;AA0OEa,4BAA0BlC,UAAUqB,IA1OtC;;AAmPEc,mCAAiCnC,UAAUqB,IAnP7C;;AAiQEe,WAASvC,kBAjQX;;AA4QEwC,YAAUrC,UAAUqB,IA5QtB;;AA+SEiB,iBAAetC,UAAUa,KAAV,CAAgB,CAC7B,UAD6B,EAE7B,MAF6B,EAG7B,UAH6B,EAI7B,MAJ6B,CAAhB,CA/SjB;AAqTE0B,SAAOlC,aArTT;;AA+TEmC,yBAAuBxC,UAAUS,IA/TnC;;AA+UEgC,kCAAgCzC,UAAUS,IA/U5C;;AA+VEiC,sBAAoB1C,UAAUS,IA/VhC;;AAyWEkC,eAAa3C,UAAUS,IAzWzB;;AAgYEmC,kCAAgC5C,UAAUS;AAhY5C","sourcesContent":["/**\n * Copyright (c) 2015-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule ViewPropTypes\n * @flow\n */\n'use strict';\n\nconst EdgeInsetsPropType = require('EdgeInsetsPropType');\nconst PlatformViewPropTypes = require('PlatformViewPropTypes');\nconst PropTypes = require('prop-types');\nconst StyleSheetPropType = require('StyleSheetPropType');\nconst ViewStylePropTypes = require('ViewStylePropTypes');\n\nconst {\n  AccessibilityComponentTypes,\n  AccessibilityTraits,\n} = require('ViewAccessibility');\n\nimport type {\n  AccessibilityComponentType,\n  AccessibilityTrait,\n} from 'ViewAccessibility';\nimport type {EdgeInsetsProp} from 'EdgeInsetsPropType';\nimport type {TVViewProps} from 'TVViewPropTypes';\n\nconst stylePropType = StyleSheetPropType(ViewStylePropTypes);\n\nexport type ViewLayout = {\n  x: number,\n  y: number,\n  width: number,\n  height: number,\n}\n\nexport type ViewLayoutEvent = {\n  nativeEvent: {\n    layout: ViewLayout,\n  }\n}\n\n// There's no easy way to create a different type if(Platform.isTVOS):\n// so we must include TVViewProps\nexport type ViewProps = {\n  accessible?: bool,\n  accessibilityLabel?: React$PropType$Primitive<any>,\n  accessibilityComponentType?: AccessibilityComponentType,\n  accessibilityLiveRegion?: 'none' | 'polite' | 'assertive',\n  importantForAccessibility?: 'auto'| 'yes'| 'no'| 'no-hide-descendants',\n  accessibilityTraits?: AccessibilityTrait | Array<AccessibilityTrait>,\n  accessibilityViewIsModal?: bool,\n  onAccessibilityTap?: Function,\n  onMagicTap?: Function,\n  testID?: string,\n  nativeID?: string,\n  onLayout?: (event: ViewLayoutEvent) => void,\n  onResponderGrant?: Function,\n  onResponderMove?: Function,\n  onResponderReject?: Function,\n  onResponderRelease?: Function,\n  onResponderTerminate?: Function,\n  onResponderTerminationRequest?: Function,\n  onStartShouldSetResponder?: Function,\n  onStartShouldSetResponderCapture?: Function,\n  onMoveShouldSetResponder?: Function,\n  onMoveShouldSetResponderCapture?: Function,\n  hitSlop?: EdgeInsetsProp,\n  pointerEvents?: 'box-none'| 'none'| 'box-only'| 'auto',\n  style?: stylePropType,\n  removeClippedSubviews?: bool,\n  renderToHardwareTextureAndroid?: bool,\n  shouldRasterizeIOS?: bool,\n  collapsable?: bool,\n  needsOffscreenAlphaCompositing?: bool,\n} & TVViewProps;\n\nmodule.exports = {\n  ...PlatformViewPropTypes,\n\n  /**\n   * When `true`, indicates that the view is an accessibility element. By default,\n   * all the touchable elements are accessible.\n   */\n  accessible: PropTypes.bool,\n\n  /**\n   * Overrides the text that's read by the screen reader when the user interacts\n   * with the element. By default, the label is constructed by traversing all the\n   * children and accumulating all the `Text` nodes separated by space.\n   */\n  accessibilityLabel: PropTypes.node,\n\n  /**\n   * Indicates to accessibility services to treat UI component like a\n   * native one. Works for Android only.\n   *\n   * Possible values are one of:\n   *\n   * - `'none'`\n   * - `'button'`\n   * - `'radiobutton_checked'`\n   * - `'radiobutton_unchecked'`\n   *\n   * @platform android\n   */\n  accessibilityComponentType: PropTypes.oneOf(AccessibilityComponentTypes),\n\n  /**\n   * Indicates to accessibility services whether the user should be notified\n   * when this view changes. Works for Android API >= 19 only.\n   * Possible values:\n   *\n   * - `'none'` - Accessibility services should not announce changes to this view.\n   * - `'polite'`- Accessibility services should announce changes to this view.\n   * - `'assertive'` - Accessibility services should interrupt ongoing speech to immediately announce changes to this view.\n   *\n   * See the [Android `View` docs](http://developer.android.com/reference/android/view/View.html#attr_android:accessibilityLiveRegion)\n   * for reference.\n   *\n   * @platform android\n   */\n  accessibilityLiveRegion: PropTypes.oneOf([\n    'none',\n    'polite',\n    'assertive',\n  ]),\n\n  /**\n   * Controls how view is important for accessibility which is if it\n   * fires accessibility events and if it is reported to accessibility services\n   * that query the screen. Works for Android only.\n   *\n   * Possible values:\n   *\n   *  - `'auto'` - The system determines whether the view is important for accessibility -\n   *    default (recommended).\n   *  - `'yes'` - The view is important for accessibility.\n   *  - `'no'` - The view is not important for accessibility.\n   *  - `'no-hide-descendants'` - The view is not important for accessibility,\n   *    nor are any of its descendant views.\n   *\n   * See the [Android `importantForAccessibility` docs](http://developer.android.com/reference/android/R.attr.html#importantForAccessibility)\n   * for reference.\n   *\n   * @platform android\n   */\n  importantForAccessibility: PropTypes.oneOf([\n    'auto',\n    'yes',\n    'no',\n    'no-hide-descendants',\n  ]),\n\n  /**\n   * Provides additional traits to screen reader. By default no traits are\n   * provided unless specified otherwise in element.\n   *\n   * You can provide one trait or an array of many traits.\n   *\n   * Possible values for `AccessibilityTraits` are:\n   *\n   * - `'none'` - The element has no traits.\n   * - `'button'` - The element should be treated as a button.\n   * - `'link'` - The element should be treated as a link.\n   * - `'header'` - The element is a header that divides content into sections.\n   * - `'search'` - The element should be treated as a search field.\n   * - `'image'` - The element should be treated as an image.\n   * - `'selected'` - The element is selected.\n   * - `'plays'` - The element plays sound.\n   * - `'key'` - The element should be treated like a keyboard key.\n   * - `'text'` - The element should be treated as text.\n   * - `'summary'` - The element provides app summary information.\n   * - `'disabled'` - The element is disabled.\n   * - `'frequentUpdates'` - The element frequently changes its value.\n   * - `'startsMedia'` - The element starts a media session.\n   * - `'adjustable'` - The element allows adjustment over a range of values.\n   * - `'allowsDirectInteraction'` - The element allows direct touch interaction for VoiceOver users.\n   * - `'pageTurn'` - Informs VoiceOver that it should scroll to the next page when it finishes reading the contents of the element.\n   *\n   * See the [Accessibility guide](docs/accessibility.html#accessibilitytraits-ios)\n   * for more information.\n   *\n   * @platform ios\n   */\n  accessibilityTraits: PropTypes.oneOfType([\n    PropTypes.oneOf(AccessibilityTraits),\n    PropTypes.arrayOf(PropTypes.oneOf(AccessibilityTraits)),\n  ]),\n\n  /**\n   * A value indicating whether VoiceOver should ignore the elements\n   * within views that are siblings of the receiver.\n   * Default is `false`.\n   *\n   * See the [Accessibility guide](docs/accessibility.html#accessibilitytraits-ios)\n   * for more information.\n   *\n   * @platform ios\n   */\n  accessibilityViewIsModal: PropTypes.bool,\n\n  /**\n   * When `accessible` is true, the system will try to invoke this function\n   * when the user performs accessibility tap gesture.\n   */\n  onAccessibilityTap: PropTypes.func,\n\n  /**\n   * When `accessible` is `true`, the system will invoke this function when the\n   * user performs the magic tap gesture.\n   */\n  onMagicTap: PropTypes.func,\n\n  /**\n   * Used to locate this view in end-to-end tests.\n   *\n   * > This disables the 'layout-only view removal' optimization for this view!\n   */\n  testID: PropTypes.string,\n\n  /**\n   * Used to locate this view from native classes.\n   *\n   * > This disables the 'layout-only view removal' optimization for this view!\n   */\n  nativeID: PropTypes.string,\n\n  /**\n   * For most touch interactions, you'll simply want to wrap your component in\n   * `TouchableHighlight` or `TouchableOpacity`. Check out `Touchable.js`,\n   * `ScrollResponder.js` and `ResponderEventPlugin.js` for more discussion.\n   */\n\n  /**\n   * The View is now responding for touch events. This is the time to highlight and show the user\n   * what is happening.\n   *\n   * `View.props.onResponderGrant: (event) => {}`, where `event` is a synthetic touch event as\n   * described above.\n   */\n  onResponderGrant: PropTypes.func,\n\n  /**\n   * The user is moving their finger.\n   *\n   * `View.props.onResponderMove: (event) => {}`, where `event` is a synthetic touch event as\n   * described above.\n   */\n  onResponderMove: PropTypes.func,\n\n  /**\n   * Another responder is already active and will not release it to that `View` asking to be\n   * the responder.\n   *\n   * `View.props.onResponderReject: (event) => {}`, where `event` is a synthetic touch event as\n   * described above.\n   */\n  onResponderReject: PropTypes.func,\n\n  /**\n   * Fired at the end of the touch.\n   *\n   * `View.props.onResponderRelease: (event) => {}`, where `event` is a synthetic touch event as\n   * described above.\n   */\n  onResponderRelease: PropTypes.func,\n\n  /**\n   * The responder has been taken from the `View`. Might be taken by other views after a call to\n   * `onResponderTerminationRequest`, or might be taken by the OS without asking (e.g., happens\n   * with control center/ notification center on iOS)\n   *\n   * `View.props.onResponderTerminate: (event) => {}`, where `event` is a synthetic touch event as\n   * described above.\n   */\n  onResponderTerminate: PropTypes.func,\n\n  /**\n   * Some other `View` wants to become responder and is asking this `View` to release its\n   * responder. Returning `true` allows its release.\n   *\n   * `View.props.onResponderTerminationRequest: (event) => {}`, where `event` is a synthetic touch\n   * event as described above.\n   */\n  onResponderTerminationRequest: PropTypes.func,\n\n  /**\n   * Does this view want to become responder on the start of a touch?\n   *\n   * `View.props.onStartShouldSetResponder: (event) => [true | false]`, where `event` is a\n   * synthetic touch event as described above.\n   */\n  onStartShouldSetResponder: PropTypes.func,\n\n  /**\n   * If a parent `View` wants to prevent a child `View` from becoming responder on a touch start,\n   * it should have this handler which returns `true`.\n   *\n   * `View.props.onStartShouldSetResponderCapture: (event) => [true | false]`, where `event` is a\n   * synthetic touch event as described above.\n   */\n  onStartShouldSetResponderCapture: PropTypes.func,\n\n  /**\n   * Does this view want to \"claim\" touch responsiveness? This is called for every touch move on\n   * the `View` when it is not the responder.\n   *\n   * `View.props.onMoveShouldSetResponder: (event) => [true | false]`, where `event` is a\n   * synthetic touch event as described above.\n   */\n  onMoveShouldSetResponder: PropTypes.func,\n\n  /**\n  * If a parent `View` wants to prevent a child `View` from becoming responder on a move,\n  * it should have this handler which returns `true`.\n  *\n  * `View.props.onMoveShouldSetResponderCapture: (event) => [true | false]`, where `event` is a\n  * synthetic touch event as described above.\n   */\n  onMoveShouldSetResponderCapture: PropTypes.func,\n\n  /**\n   * This defines how far a touch event can start away from the view.\n   * Typical interface guidelines recommend touch targets that are at least\n   * 30 - 40 points/density-independent pixels.\n   *\n   * For example, if a touchable view has a height of 20 the touchable height can be extended to\n   * 40 with `hitSlop={{top: 10, bottom: 10, left: 0, right: 0}}`\n   *\n   * > The touch area never extends past the parent view bounds and the Z-index\n   * > of sibling views always takes precedence if a touch hits two overlapping\n   * > views.\n   */\n  hitSlop: EdgeInsetsPropType,\n\n  /**\n   * Invoked on mount and layout changes with:\n   *\n   * `{nativeEvent: { layout: {x, y, width, height}}}`\n   *\n   * This event is fired immediately once the layout has been calculated, but\n   * the new layout may not yet be reflected on the screen at the time the\n   * event is received, especially if a layout animation is in progress.\n   */\n  onLayout: PropTypes.func,\n\n  /**\n   * Controls whether the `View` can be the target of touch events.\n   *\n   *   - `'auto'`: The View can be the target of touch events.\n   *   - `'none'`: The View is never the target of touch events.\n   *   - `'box-none'`: The View is never the target of touch events but it's\n   *     subviews can be. It behaves like if the view had the following classes\n   *     in CSS:\n   * ```\n   * .box-none {\n   *      pointer-events: none;\n   * }\n   * .box-none * {\n   *      pointer-events: all;\n   * }\n   * ```\n   *   - `'box-only'`: The view can be the target of touch events but it's\n   *     subviews cannot be. It behaves like if the view had the following classes\n   *     in CSS:\n   * ```\n   * .box-only {\n   *      pointer-events: all;\n   * }\n   * .box-only * {\n   *      pointer-events: none;\n   * }\n   * ```\n   * > Since `pointerEvents` does not affect layout/appearance, and we are\n   * > already deviating from the spec by adding additional modes, we opt to not\n   * > include `pointerEvents` on `style`. On some platforms, we would need to\n   * > implement it as a `className` anyways. Using `style` or not is an\n   * > implementation detail of the platform.\n   */\n  pointerEvents: PropTypes.oneOf([\n    'box-none',\n    'none',\n    'box-only',\n    'auto',\n  ]),\n  style: stylePropType,\n\n  /**\n   * This is a special performance property exposed by `RCTView` and is useful\n   * for scrolling content when there are many subviews, most of which are\n   * offscreen. For this property to be effective, it must be applied to a\n   * view that contains many subviews that extend outside its bound. The\n   * subviews must also have `overflow: hidden`, as should the containing view\n   * (or one of its superviews).\n   */\n  removeClippedSubviews: PropTypes.bool,\n\n  /**\n   * Whether this `View` should render itself (and all of its children) into a\n   * single hardware texture on the GPU.\n   *\n   * On Android, this is useful for animations and interactions that only\n   * modify opacity, rotation, translation, and/or scale: in those cases, the\n   * view doesn't have to be redrawn and display lists don't need to be\n   * re-executed. The texture can just be re-used and re-composited with\n   * different parameters. The downside is that this can use up limited video\n   * memory, so this prop should be set back to false at the end of the\n   * interaction/animation.\n   *\n   * @platform android\n   */\n  renderToHardwareTextureAndroid: PropTypes.bool,\n\n  /**\n   * Whether this `View` should be rendered as a bitmap before compositing.\n   *\n   * On iOS, this is useful for animations and interactions that do not\n   * modify this component's dimensions nor its children; for example, when\n   * translating the position of a static view, rasterization allows the\n   * renderer to reuse a cached bitmap of a static view and quickly composite\n   * it during each frame.\n   *\n   * Rasterization incurs an off-screen drawing pass and the bitmap consumes\n   * memory. Test and measure when using this property.\n   *\n   * @platform ios\n   */\n  shouldRasterizeIOS: PropTypes.bool,\n\n  /**\n   * Views that are only used to layout their children or otherwise don't draw\n   * anything may be automatically removed from the native hierarchy as an\n   * optimization. Set this property to `false` to disable this optimization and\n   * ensure that this `View` exists in the native view hierarchy.\n   *\n   * @platform android\n   */\n  collapsable: PropTypes.bool,\n\n  /**\n   * Whether this `View` needs to rendered offscreen and composited with an alpha\n   * in order to preserve 100% correct colors and blending behavior. The default\n   * (`false`) falls back to drawing the component and its children with an alpha\n   * applied to the paint used to draw each element instead of rendering the full\n   * component offscreen and compositing it back with an alpha value. This default\n   * may be noticeable and undesired in the case where the `View` you are setting\n   * an opacity on has multiple overlapping elements (e.g. multiple overlapping\n   * `View`s, or text and a background).\n   *\n   * Rendering offscreen to preserve correct alpha behavior is extremely\n   * expensive and hard to debug for non-native developers, which is why it is\n   * not turned on by default. If you do need to enable this property for an\n   * animation, consider combining it with renderToHardwareTextureAndroid if the\n   * view **contents** are static (i.e. it doesn't need to be redrawn each frame).\n   * If that property is enabled, this View will be rendered off-screen once,\n   * saved in a hardware texture, and then composited onto the screen with an alpha\n   * each frame without having to switch rendering targets on the GPU.\n   *\n   * @platform android\n   */\n  needsOffscreenAlphaCompositing: PropTypes.bool,\n};\n"]}]