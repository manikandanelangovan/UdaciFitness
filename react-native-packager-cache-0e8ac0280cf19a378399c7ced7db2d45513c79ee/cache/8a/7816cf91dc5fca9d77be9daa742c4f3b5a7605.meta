["cd2586f3f58d4028674029359d092cb8bbf357c5","3ccd4b706eb0f1c41a19abc2fbadc43a3d49dfd2",["Dimensions","FrameRateLogger","Keyboard","ReactNative","Subscribable","TextInputState","UIManager","fbjs/lib/invariant","fbjs/lib/nullthrows","fbjs/lib/performanceNow","fbjs/lib/warning","NativeModules","ReactNativeComponentTree"],[41,86,129,168,211,257,300,339,387,440,490,535,630],{"version":3,"sources":["/Users/mani/Documents/Udacity/Core/React_Native/UdaciFitness/node_modules/react-native/Libraries/Components/ScrollResponder.js"],"names":["Dimensions","require","FrameRateLogger","Keyboard","ReactNative","Subscribable","TextInputState","UIManager","invariant","nullthrows","performanceNow","warning","ScrollViewManager","getInstanceFromNode","IS_ANIMATING_TOUCH_START_THRESHOLD_MS","isTagInstanceOfTextInput","tag","instance","viewConfig","uiViewClassName","ScrollResponderMixin","mixins","Mixin","scrollResponderMixinGetInitialState","isTouching","lastMomentumScrollBeginTime","lastMomentumScrollEndTime","observedScrollSinceBecomingResponder","becameResponderWhileAnimating","scrollResponderHandleScrollShouldSetResponder","state","scrollResponderHandleStartShouldSetResponder","e","currentlyFocusedTextInput","currentlyFocusedField","props","keyboardShouldPersistTaps","target","scrollResponderHandleStartShouldSetResponderCapture","keyboardNeverPersistTaps","scrollResponderIsAnimating","scrollResponderHandleResponderReject","scrollResponderHandleTerminationRequest","scrollResponderHandleTouchEnd","nativeEvent","touches","length","onTouchEnd","scrollResponderHandleResponderRelease","onResponderRelease","onScrollResponderKeyboardDismissed","blurTextInput","scrollResponderHandleScroll","onScroll","scrollResponderHandleResponderGrant","onResponderGrant","scrollResponderHandleScrollBeginDrag","beginScroll","onScrollBeginDrag","scrollResponderHandleScrollEndDrag","velocity","x","y","endScroll","onScrollEndDrag","scrollResponderHandleMomentumScrollBegin","onMomentumScrollBegin","scrollResponderHandleMomentumScrollEnd","onMomentumScrollEnd","scrollResponderHandleTouchStart","onTouchStart","scrollResponderHandleTouchMove","onTouchMove","now","timeSinceLastMomentumScrollEnd","isAnimating","scrollResponderGetScrollableNode","getScrollableNode","findNodeHandle","scrollResponderScrollTo","animated","console","warn","dispatchViewManagerCommand","RCTScrollView","Commands","scrollTo","scrollResponderScrollToEnd","options","scrollToEnd","scrollResponderScrollWithoutAnimationTo","offsetX","offsetY","scrollResponderZoomTo","rect","zoomToRect","scrollResponderFlashScrollIndicators","flashScrollIndicators","scrollResponderScrollNativeHandleToKeyboard","nodeHandle","additionalOffset","preventNegativeScrollOffset","additionalScrollOffset","measureLayout","getInnerViewNode","scrollResponderTextInputFocusError","scrollResponderInputMeasureAndScrollToKeyboard","left","top","width","height","keyboardScreenY","get","keyboardWillOpenTo","endCoordinates","screenY","scrollOffsetY","Math","max","error","componentWillMount","addListenerOn","scrollResponderKeyboardWillShow","scrollResponderKeyboardWillHide","scrollResponderKeyboardDidShow","scrollResponderKeyboardDidHide","onKeyboardWillShow","onKeyboardWillHide","onKeyboardDidShow","onKeyboardDidHide","ScrollResponder","module","exports"],"mappings":";AAWA;;AAEA,IAAIA,aAAaC,OAAb,cAAJ;AACA,IAAIC,kBAAkBD,OAAlB,mBAAJ;AACA,IAAIE,WAAWF,OAAX,YAAJ;AACA,IAAIG,cAAcH,OAAd,eAAJ;AACA,IAAII,eAAeJ,OAAf,gBAAJ;AACA,IAAIK,iBAAiBL,OAAjB,kBAAJ;AACA,IAAIM,YAAYN,OAAZ,aAAJ;;AAEA,IAAIO,YAAYP,OAAZ,sBAAJ;AACA,IAAIQ,aAAaR,OAAb,uBAAJ;AACA,IAAIS,iBAAiBT,OAAjB,2BAAJ;AACA,IAAIU,UAAUV,OAAV,oBAAJ;;eAE4BA,O;IAAtBW,iB,YAAAA,iB;;gBACwBX,O;IAAxBY,mB,aAAAA,mB;;AAgFN,IAAIC,wCAAwC,EAA5C;;AAWA,SAASC,wBAAT,CAAkCC,GAAlC,EAAuC;AACrC,MAAIC,WAAWJ,oBAAoBG,GAApB,CAAf;AACA,SAAOC,YAAYA,SAASC,UAArB,KACLD,SAASC,UAAT,CAAoBC,eAApB,KAAwC,kBAAxC,IACAF,SAASC,UAAT,CAAoBC,eAApB,KAAwC,aADxC,IAEAF,SAASC,UAAT,CAAoBC,eAApB,KAAwC,cAHnC,CAAP;AAKD;;AAED,IAAIC,uBAAuB;AACzBC,UAAQ,CAAChB,aAAaiB,KAAd,CADiB;AAEzBC,uCAAqC,+CAAkB;AACrD,WAAO;AACLC,kBAAY,KADP;AAELC,mCAA6B,CAFxB;AAGLC,iCAA2B,CAHtB;;AAULC,4CAAsC,KAVjC;AAWLC,qCAA+B;AAX1B,KAAP;AAaD,GAhBwB;;AAqBzBC,iDAA+C,yDAAoB;AACjE,WAAO,KAAKC,KAAL,CAAWN,UAAlB;AACD,GAvBwB;;AAkDzBO,gDAA8C,sDAASC,CAAT,EAA4B;AACxE,QAAIC,4BAA4B3B,eAAe4B,qBAAf,EAAhC;;AAEA,QAAI,KAAKC,KAAL,CAAWC,yBAAX,KAAyC,SAAzC,IACFH,6BAA6B,IAD3B,IAEFD,EAAEK,MAAF,KAAaJ,yBAFf,EAE0C;AACxC,aAAO,IAAP;AACD;AACD,WAAO,KAAP;AACD,GA3DwB;;AAwEzBK,uDAAqD,6DAASN,CAAT,EAA4B;AAE/E,QAAIC,4BAA4B3B,eAAe4B,qBAAf,EAAhC;AAF+E,QAG1EE,yBAH0E,GAG7C,KAAKD,KAHwC,CAG1EC,yBAH0E;;AAI/E,QAAIG,2BAA2B,CAACH,yBAAD,IACCA,8BAA8B,OAD9D;AAEA,QAAIG,4BACFN,6BAA6B,IAD3B,IAEF,CAAClB,yBAAyBiB,EAAEK,MAA3B,CAFH,EAEuC;AACrC,aAAO,IAAP;AACD;AACD,WAAO,KAAKG,0BAAL,EAAP;AACD,GApFwB;;AAgGzBC,wCAAsC,gDAAW,CAChD,CAjGwB;;AAkHzBC,2CAAyC,mDAAoB;AAC3D,WAAO,CAAC,KAAKZ,KAAL,CAAWH,oCAAnB;AACD,GApHwB;;AA2HzBgB,iCAA+B,uCAASX,CAAT,EAAmB;AAChD,QAAIY,cAAcZ,EAAEY,WAApB;AACA,SAAKd,KAAL,CAAWN,UAAX,GAAwBoB,YAAYC,OAAZ,CAAoBC,MAApB,KAA+B,CAAvD;AACA,SAAKX,KAAL,CAAWY,UAAX,IAAyB,KAAKZ,KAAL,CAAWY,UAAX,CAAsBf,CAAtB,CAAzB;AACD,GA/HwB;;AAoIzBgB,yCAAuC,+CAAShB,CAAT,EAAmB;AACxD,SAAKG,KAAL,CAAWc,kBAAX,IAAiC,KAAKd,KAAL,CAAWc,kBAAX,CAA8BjB,CAA9B,CAAjC;;AAIA,QAAIC,4BAA4B3B,eAAe4B,qBAAf,EAAhC;AACA,QAAI,KAAKC,KAAL,CAAWC,yBAAX,KAAyC,IAAzC,IACF,KAAKD,KAAL,CAAWC,yBAAX,KAAyC,QADvC,IAEFH,6BAA6B,IAF3B,IAGFD,EAAEK,MAAF,KAAaJ,yBAHX,IAIF,CAAC,KAAKH,KAAL,CAAWH,oCAJV,IAKF,CAAC,KAAKG,KAAL,CAAWF,6BALd,EAK6C;AAC3C,WAAKO,KAAL,CAAWe,kCAAX,IACE,KAAKf,KAAL,CAAWe,kCAAX,CAA8ClB,CAA9C,CADF;AAEA1B,qBAAe6C,aAAf,CAA6BlB,yBAA7B;AACD;AACF,GApJwB;;AAsJzBmB,+BAA6B,qCAASpB,CAAT,EAAmB;AAC9C,SAAKF,KAAL,CAAWH,oCAAX,GAAkD,IAAlD;AACA,SAAKQ,KAAL,CAAWkB,QAAX,IAAuB,KAAKlB,KAAL,CAAWkB,QAAX,CAAoBrB,CAApB,CAAvB;AACD,GAzJwB;;AA8JzBsB,uCAAqC,6CAAStB,CAAT,EAAmB;AACtD,SAAKF,KAAL,CAAWH,oCAAX,GAAkD,KAAlD;AACA,SAAKQ,KAAL,CAAWoB,gBAAX,IAA+B,KAAKpB,KAAL,CAAWoB,gBAAX,CAA4BvB,CAA5B,CAA/B;AACA,SAAKF,KAAL,CAAWF,6BAAX,GAA2C,KAAKY,0BAAL,EAA3C;AACD,GAlKwB;;AA2KzBgB,wCAAsC,8CAASxB,CAAT,EAAmB;AACvD9B,oBAAgBuD,WAAhB;AACA,SAAKtB,KAAL,CAAWuB,iBAAX,IAAgC,KAAKvB,KAAL,CAAWuB,iBAAX,CAA6B1B,CAA7B,CAAhC;AACD,GA9KwB;;AAmLzB2B,sCAAoC,4CAAS3B,CAAT,EAAmB;AAAA,QAC9C4B,QAD8C,GAClC5B,EAAEY,WADgC,CAC9CgB,QAD8C;;AAOrD,QAAI,CAAC,KAAKpB,0BAAL,EAAD,KACC,CAACoB,QAAD,IAAaA,SAASC,CAAT,KAAe,CAAf,IAAoBD,SAASE,CAAT,KAAe,CADjD,CAAJ,EACyD;AACvD5D,sBAAgB6D,SAAhB;AACD;AACD,SAAK5B,KAAL,CAAW6B,eAAX,IAA8B,KAAK7B,KAAL,CAAW6B,eAAX,CAA2BhC,CAA3B,CAA9B;AACD,GA/LwB;;AAoMzBiC,4CAA0C,kDAASjC,CAAT,EAAmB;AAC3D,SAAKF,KAAL,CAAWL,2BAAX,GAAyCf,gBAAzC;AACA,SAAKyB,KAAL,CAAW+B,qBAAX,IAAoC,KAAK/B,KAAL,CAAW+B,qBAAX,CAAiClC,CAAjC,CAApC;AACD,GAvMwB;;AA4MzBmC,0CAAwC,gDAASnC,CAAT,EAAmB;AACzD9B,oBAAgB6D,SAAhB;AACA,SAAKjC,KAAL,CAAWJ,yBAAX,GAAuChB,gBAAvC;AACA,SAAKyB,KAAL,CAAWiC,mBAAX,IAAkC,KAAKjC,KAAL,CAAWiC,mBAAX,CAA+BpC,CAA/B,CAAlC;AACD,GAhNwB;;AA6NzBqC,mCAAiC,yCAASrC,CAAT,EAAmB;AAClD,SAAKF,KAAL,CAAWN,UAAX,GAAwB,IAAxB;AACA,SAAKW,KAAL,CAAWmC,YAAX,IAA2B,KAAKnC,KAAL,CAAWmC,YAAX,CAAwBtC,CAAxB,CAA3B;AACD,GAhOwB;;AA6OzBuC,kCAAgC,wCAASvC,CAAT,EAAmB;AACjD,SAAKG,KAAL,CAAWqC,WAAX,IAA0B,KAAKrC,KAAL,CAAWqC,WAAX,CAAuBxC,CAAvB,CAA1B;AACD,GA/OwB;;AAsPzBQ,8BAA4B,sCAAoB;AAC9C,QAAIiC,MAAM/D,gBAAV;AACA,QAAIgE,iCAAiCD,MAAM,KAAK3C,KAAL,CAAWJ,yBAAtD;AACA,QAAIiD,cAAcD,iCAAiC5D,qCAAjC,IAChB,KAAKgB,KAAL,CAAWJ,yBAAX,GAAuC,KAAKI,KAAL,CAAWL,2BADpD;AAEA,WAAOkD,WAAP;AACD,GA5PwB;;AAmQzBC,oCAAkC,4CAAgB;AAChD,WAAO,KAAKC,iBAAL,GACL,KAAKA,iBAAL,EADK,GAELzE,YAAY0E,cAAZ,CAA2B,IAA3B,CAFF;AAGD,GAvQwB;;AAoRzBC,2BAAyB,iCACvBlB,CADuB,EAEvBC,CAFuB,EAGvBkB,QAHuB,EAIvB;AACA,QAAI,OAAOnB,CAAP,KAAa,QAAjB,EAA2B;AACzBoB,cAAQC,IAAR,CAAa,+HAAb;AACD,KAFD,MAEO;AAAA,iBACerB,KAAK,EADpB;;AACHA,OADG,QACHA,CADG;AACAC,OADA,QACAA,CADA;AACGkB,cADH,QACGA,QADH;AAEN;AACDzE,cAAU4E,0BAAV,CACE1E,WAAW,KAAKmE,gCAAL,EAAX,CADF,EAEErE,UAAU6E,aAAV,CAAwBC,QAAxB,CAAiCC,QAFnC,EAGE,CAACzB,KAAK,CAAN,EAASC,KAAK,CAAd,EAAiBkB,aAAa,KAA9B,CAHF;AAKD,GAnSwB;;AA6SzBO,8BAA4B,oCAC1BC,OAD0B,EAE1B;AAEA,QAAMR,WAAW,CAACQ,WAAWA,QAAQR,QAApB,MAAkC,KAAnD;AACAzE,cAAU4E,0BAAV,CACE,KAAKP,gCAAL,EADF,EAEErE,UAAU6E,aAAV,CAAwBC,QAAxB,CAAiCI,WAFnC,EAGE,CAACT,QAAD,CAHF;AAKD,GAvTwB;;AA4TzBU,2CAAyC,iDAASC,OAAT,EAA0BC,OAA1B,EAA2C;AAClFX,YAAQC,IAAR,CAAa,gGAAb;AACA,SAAKH,uBAAL,CAA6B,EAAClB,GAAG8B,OAAJ,EAAa7B,GAAG8B,OAAhB,EAAyBZ,UAAU,KAAnC,EAA7B;AACD,GA/TwB;;AAuUzBa,yBAAuB,+BACrBC,IADqB,EAErBd,QAFqB,EAGrB;AACAxE,cAAUI,qBAAqBA,kBAAkBmF,UAAjD,EAA6D,+BAA7D;AACA,QAAI,cAAcD,IAAlB,EAAwB;AAAA,UAChBd,QADgB,GACMc,IADN,CAChBd,QADgB;AAAA,UACHc,IADG,wCACMA,IADN;AAEvB,KAFD,MAEO,IAAI,OAAOd,QAAP,KAAoB,WAAxB,EAAqC;AAC1CC,cAAQC,IAAR,CAAa,2FAAb;AACD;AACDtE,sBAAkBmF,UAAlB,CAA6B,KAAKnB,gCAAL,EAA7B,EAAsEkB,IAAtE,EAA4Ed,aAAa,KAAzF;AACD,GAlVwB;;AAuVzBgB,wCAAsC,gDAAW;AAC/CzF,cAAU4E,0BAAV,CACE,KAAKP,gCAAL,EADF,EAEErE,UAAU6E,aAAV,CAAwBC,QAAxB,CAAiCY,qBAFnC,EAGE,EAHF;AAKD,GA7VwB;;AAyWzBC,+CAA6C,qDAASC,UAAT,EAA0BC,gBAA1B,EAAqDC,2BAArD,EAAyF;AACpI,SAAKC,sBAAL,GAA8BF,oBAAoB,CAAlD;AACA,SAAKC,2BAAL,GAAmC,CAAC,CAACA,2BAArC;AACA9F,cAAUgG,aAAV,CACEJ,UADF,EAEE/F,YAAY0E,cAAZ,CAA2B,KAAK0B,gBAAL,EAA3B,CAFF,EAGE,KAAKC,kCAHP,EAIE,KAAKC,8CAJP;AAMD,GAlXwB;;AA8XzBA,kDAAgD,wDAASC,IAAT,EAAuBC,GAAvB,EAAoCC,KAApC,EAAmDC,MAAnD,EAAmE;AACjH,QAAIC,kBAAkB/G,WAAWgH,GAAX,CAAe,QAAf,EAAyBF,MAA/C;AACA,QAAI,KAAKG,kBAAT,EAA6B;AAC3BF,wBAAkB,KAAKE,kBAAL,CAAwBC,cAAxB,CAAuCC,OAAzD;AACD;AACD,QAAIC,gBAAgBR,MAAMG,eAAN,GAAwBD,MAAxB,GAAiC,KAAKR,sBAA1D;;AAMA,QAAI,KAAKD,2BAAT,EAAsC;AACpCe,sBAAgBC,KAAKC,GAAL,CAAS,CAAT,EAAYF,aAAZ,CAAhB;AACD;AACD,SAAKrC,uBAAL,CAA6B,EAAClB,GAAG,CAAJ,EAAOC,GAAGsD,aAAV,EAAyBpC,UAAU,IAAnC,EAA7B;;AAEA,SAAKoB,gBAAL,GAAwB,CAAxB;AACA,SAAKC,2BAAL,GAAmC,KAAnC;AACD,GAhZwB;;AAkZzBI,sCAAoC,4CAASzE,CAAT,EAAmB;AACrDiD,YAAQsC,KAAR,CAAc,8BAAd,EAA8CvF,CAA9C;AACD,GApZwB;;AA4ZzBwF,sBAAoB,8BAAW;AAAA,QACxBpF,yBADwB,GACK,KAAKD,KADV,CACxBC,yBADwB;;AAE7BzB,YACE,OAAOyB,yBAAP,KAAqC,SADvC,EAEE,kCAA+BA,yBAA/B,mEACqCA,4BAA4B,QAA5B,GAAuC,OAD5E,kBAFF;;AAMA,SAAK6E,kBAAL,GAA0B,IAA1B;AACA,SAAKX,sBAAL,GAA8B,CAA9B;AACA,SAAKmB,aAAL,CAAmBtH,QAAnB,EAA6B,kBAA7B,EAAiD,KAAKuH,+BAAtD;AACA,SAAKD,aAAL,CAAmBtH,QAAnB,EAA6B,kBAA7B,EAAiD,KAAKwH,+BAAtD;AACA,SAAKF,aAAL,CAAmBtH,QAAnB,EAA6B,iBAA7B,EAAgD,KAAKyH,8BAArD;AACA,SAAKH,aAAL,CAAmBtH,QAAnB,EAA6B,iBAA7B,EAAgD,KAAK0H,8BAArD;AACD,GA1awB;;AAwczBH,mCAAiC,yCAAS1F,CAAT,EAAmB;AAClD,SAAKiF,kBAAL,GAA0BjF,CAA1B;AACA,SAAKG,KAAL,CAAW2F,kBAAX,IAAiC,KAAK3F,KAAL,CAAW2F,kBAAX,CAA8B9F,CAA9B,CAAjC;AACD,GA3cwB;;AA6czB2F,mCAAiC,yCAAS3F,CAAT,EAAmB;AAClD,SAAKiF,kBAAL,GAA0B,IAA1B;AACA,SAAK9E,KAAL,CAAW4F,kBAAX,IAAiC,KAAK5F,KAAL,CAAW4F,kBAAX,CAA8B/F,CAA9B,CAAjC;AACD,GAhdwB;;AAkdzB4F,kCAAgC,wCAAS5F,CAAT,EAAmB;AAGjD,QAAIA,CAAJ,EAAO;AACL,WAAKiF,kBAAL,GAA0BjF,CAA1B;AACD;AACD,SAAKG,KAAL,CAAW6F,iBAAX,IAAgC,KAAK7F,KAAL,CAAW6F,iBAAX,CAA6BhG,CAA7B,CAAhC;AACD,GAzdwB;;AA2dzB6F,kCAAgC,wCAAS7F,CAAT,EAAmB;AACjD,SAAKiF,kBAAL,GAA0B,IAA1B;AACA,SAAK9E,KAAL,CAAW8F,iBAAX,IAAgC,KAAK9F,KAAL,CAAW8F,iBAAX,CAA6BjG,CAA7B,CAAhC;AACD;;AA9dwB,CAA3B;;AAkeA,IAAIkG,kBAAkB;AACpB5G,SAAOF;AADa,CAAtB;;AAIA+G,OAAOC,OAAP,GAAiBF,eAAjB","sourcesContent":["/**\n * Copyright (c) 2015-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule ScrollResponder\n * @flow\n */\n'use strict';\n\nvar Dimensions = require('Dimensions');\nvar FrameRateLogger = require('FrameRateLogger');\nvar Keyboard = require('Keyboard');\nvar ReactNative = require('ReactNative');\nvar Subscribable = require('Subscribable');\nvar TextInputState = require('TextInputState');\nvar UIManager = require('UIManager');\n\nvar invariant = require('fbjs/lib/invariant');\nvar nullthrows = require('fbjs/lib/nullthrows');\nvar performanceNow = require('fbjs/lib/performanceNow');\nvar warning = require('fbjs/lib/warning');\n\nvar { ScrollViewManager } = require('NativeModules');\nvar { getInstanceFromNode } = require('ReactNativeComponentTree');\n\n/**\n * Mixin that can be integrated in order to handle scrolling that plays well\n * with `ResponderEventPlugin`. Integrate with your platform specific scroll\n * views, or even your custom built (every-frame animating) scroll views so that\n * all of these systems play well with the `ResponderEventPlugin`.\n *\n * iOS scroll event timing nuances:\n * ===============================\n *\n *\n * Scrolling without bouncing, if you touch down:\n * -------------------------------\n *\n * 1. `onMomentumScrollBegin` (when animation begins after letting up)\n *    ... physical touch starts ...\n * 2. `onTouchStartCapture`   (when you press down to stop the scroll)\n * 3. `onTouchStart`          (same, but bubble phase)\n * 4. `onResponderRelease`    (when lifting up - you could pause forever before * lifting)\n * 5. `onMomentumScrollEnd`\n *\n *\n * Scrolling with bouncing, if you touch down:\n * -------------------------------\n *\n * 1. `onMomentumScrollBegin` (when animation begins after letting up)\n *    ... bounce begins ...\n *    ... some time elapses ...\n *    ... physical touch during bounce ...\n * 2. `onMomentumScrollEnd`   (Makes no sense why this occurs first during bounce)\n * 3. `onTouchStartCapture`   (immediately after `onMomentumScrollEnd`)\n * 4. `onTouchStart`          (same, but bubble phase)\n * 5. `onTouchEnd`            (You could hold the touch start for a long time)\n * 6. `onMomentumScrollBegin` (When releasing the view starts bouncing back)\n *\n * So when we receive an `onTouchStart`, how can we tell if we are touching\n * *during* an animation (which then causes the animation to stop)? The only way\n * to tell is if the `touchStart` occurred immediately after the\n * `onMomentumScrollEnd`.\n *\n * This is abstracted out for you, so you can just call this.scrollResponderIsAnimating() if\n * necessary\n *\n * `ScrollResponder` also includes logic for blurring a currently focused input\n * if one is focused while scrolling. The `ScrollResponder` is a natural place\n * to put this logic since it can support not dismissing the keyboard while\n * scrolling, unless a recognized \"tap\"-like gesture has occurred.\n *\n * The public lifecycle API includes events for keyboard interaction, responder\n * interaction, and scrolling (among others). The keyboard callbacks\n * `onKeyboardWill/Did/*` are *global* events, but are invoked on scroll\n * responder's props so that you can guarantee that the scroll responder's\n * internal state has been updated accordingly (and deterministically) by\n * the time the props callbacks are invoke. Otherwise, you would always wonder\n * if the scroll responder is currently in a state where it recognizes new\n * keyboard positions etc. If coordinating scrolling with keyboard movement,\n * *always* use these hooks instead of listening to your own global keyboard\n * events.\n *\n * Public keyboard lifecycle API: (props callbacks)\n *\n * Standard Keyboard Appearance Sequence:\n *\n *   this.props.onKeyboardWillShow\n *   this.props.onKeyboardDidShow\n *\n * `onScrollResponderKeyboardDismissed` will be invoked if an appropriate\n * tap inside the scroll responder's scrollable region was responsible\n * for the dismissal of the keyboard. There are other reasons why the\n * keyboard could be dismissed.\n *\n *   this.props.onScrollResponderKeyboardDismissed\n *\n * Standard Keyboard Hide Sequence:\n *\n *   this.props.onKeyboardWillHide\n *   this.props.onKeyboardDidHide\n */\n\nvar IS_ANIMATING_TOUCH_START_THRESHOLD_MS = 16;\n\ntype State = {\n    isTouching: boolean,\n    lastMomentumScrollBeginTime: number,\n    lastMomentumScrollEndTime: number,\n    observedScrollSinceBecomingResponder: boolean,\n    becameResponderWhileAnimating: boolean,\n};\ntype Event = Object;\n\nfunction isTagInstanceOfTextInput(tag) {\n  var instance = getInstanceFromNode(tag);\n  return instance && instance.viewConfig && (\n    instance.viewConfig.uiViewClassName === 'AndroidTextInput' ||\n    instance.viewConfig.uiViewClassName === 'RCTTextView' ||\n    instance.viewConfig.uiViewClassName === 'RCTTextField'\n  );\n}\n\nvar ScrollResponderMixin = {\n  mixins: [Subscribable.Mixin],\n  scrollResponderMixinGetInitialState: function(): State {\n    return {\n      isTouching: false,\n      lastMomentumScrollBeginTime: 0,\n      lastMomentumScrollEndTime: 0,\n\n      // Reset to false every time becomes responder. This is used to:\n      // - Determine if the scroll view has been scrolled and therefore should\n      // refuse to give up its responder lock.\n      // - Determine if releasing should dismiss the keyboard when we are in\n      // tap-to-dismiss mode (this.props.keyboardShouldPersistTaps !== 'always').\n      observedScrollSinceBecomingResponder: false,\n      becameResponderWhileAnimating: false,\n    };\n  },\n\n  /**\n   * Invoke this from an `onScroll` event.\n   */\n  scrollResponderHandleScrollShouldSetResponder: function(): boolean {\n    return this.state.isTouching;\n  },\n\n  /**\n   * Merely touch starting is not sufficient for a scroll view to become the\n   * responder. Being the \"responder\" means that the very next touch move/end\n   * event will result in an action/movement.\n   *\n   * Invoke this from an `onStartShouldSetResponder` event.\n   *\n   * `onStartShouldSetResponder` is used when the next move/end will trigger\n   * some UI movement/action, but when you want to yield priority to views\n   * nested inside of the view.\n   *\n   * There may be some cases where scroll views actually should return `true`\n   * from `onStartShouldSetResponder`: Any time we are detecting a standard tap\n   * that gives priority to nested views.\n   *\n   * - If a single tap on the scroll view triggers an action such as\n   *   recentering a map style view yet wants to give priority to interaction\n   *   views inside (such as dropped pins or labels), then we would return true\n   *   from this method when there is a single touch.\n   *\n   * - Similar to the previous case, if a two finger \"tap\" should trigger a\n   *   zoom, we would check the `touches` count, and if `>= 2`, we would return\n   *   true.\n   *\n   */\n  scrollResponderHandleStartShouldSetResponder: function(e: Event): boolean {\n    var currentlyFocusedTextInput = TextInputState.currentlyFocusedField();\n\n    if (this.props.keyboardShouldPersistTaps === 'handled' &&\n      currentlyFocusedTextInput != null &&\n      e.target !== currentlyFocusedTextInput) {\n      return true;\n    }\n    return false;\n  },\n\n  /**\n   * There are times when the scroll view wants to become the responder\n   * (meaning respond to the next immediate `touchStart/touchEnd`), in a way\n   * that *doesn't* give priority to nested views (hence the capture phase):\n   *\n   * - Currently animating.\n   * - Tapping anywhere that is not a text input, while the keyboard is\n   *   up (which should dismiss the keyboard).\n   *\n   * Invoke this from an `onStartShouldSetResponderCapture` event.\n   */\n  scrollResponderHandleStartShouldSetResponderCapture: function(e: Event): boolean {\n    // First see if we want to eat taps while the keyboard is up\n    var currentlyFocusedTextInput = TextInputState.currentlyFocusedField();\n    var {keyboardShouldPersistTaps} = this.props;\n    var keyboardNeverPersistTaps = !keyboardShouldPersistTaps ||\n                                    keyboardShouldPersistTaps === 'never';\n    if (keyboardNeverPersistTaps &&\n      currentlyFocusedTextInput != null &&\n      !isTagInstanceOfTextInput(e.target)) {\n      return true;\n    }\n    return this.scrollResponderIsAnimating();\n  },\n\n  /**\n   * Invoke this from an `onResponderReject` event.\n   *\n   * Some other element is not yielding its role as responder. Normally, we'd\n   * just disable the `UIScrollView`, but a touch has already began on it, the\n   * `UIScrollView` will not accept being disabled after that. The easiest\n   * solution for now is to accept the limitation of disallowing this\n   * altogether. To improve this, find a way to disable the `UIScrollView` after\n   * a touch has already started.\n   */\n  scrollResponderHandleResponderReject: function() {\n  },\n\n  /**\n   * We will allow the scroll view to give up its lock iff it acquired the lock\n   * during an animation. This is a very useful default that happens to satisfy\n   * many common user experiences.\n   *\n   * - Stop a scroll on the left edge, then turn that into an outer view's\n   *   backswipe.\n   * - Stop a scroll mid-bounce at the top, continue pulling to have the outer\n   *   view dismiss.\n   * - However, without catching the scroll view mid-bounce (while it is\n   *   motionless), if you drag far enough for the scroll view to become\n   *   responder (and therefore drag the scroll view a bit), any backswipe\n   *   navigation of a swipe gesture higher in the view hierarchy, should be\n   *   rejected.\n   */\n  scrollResponderHandleTerminationRequest: function(): boolean {\n    return !this.state.observedScrollSinceBecomingResponder;\n  },\n\n  /**\n   * Invoke this from an `onTouchEnd` event.\n   *\n   * @param {SyntheticEvent} e Event.\n   */\n  scrollResponderHandleTouchEnd: function(e: Event) {\n    var nativeEvent = e.nativeEvent;\n    this.state.isTouching = nativeEvent.touches.length !== 0;\n    this.props.onTouchEnd && this.props.onTouchEnd(e);\n  },\n\n  /**\n   * Invoke this from an `onResponderRelease` event.\n   */\n  scrollResponderHandleResponderRelease: function(e: Event) {\n    this.props.onResponderRelease && this.props.onResponderRelease(e);\n\n    // By default scroll views will unfocus a textField\n    // if another touch occurs outside of it\n    var currentlyFocusedTextInput = TextInputState.currentlyFocusedField();\n    if (this.props.keyboardShouldPersistTaps !== true &&\n      this.props.keyboardShouldPersistTaps !== 'always' &&\n      currentlyFocusedTextInput != null &&\n      e.target !== currentlyFocusedTextInput  &&\n      !this.state.observedScrollSinceBecomingResponder &&\n      !this.state.becameResponderWhileAnimating) {\n      this.props.onScrollResponderKeyboardDismissed &&\n        this.props.onScrollResponderKeyboardDismissed(e);\n      TextInputState.blurTextInput(currentlyFocusedTextInput);\n    }\n  },\n\n  scrollResponderHandleScroll: function(e: Event) {\n    this.state.observedScrollSinceBecomingResponder = true;\n    this.props.onScroll && this.props.onScroll(e);\n  },\n\n  /**\n   * Invoke this from an `onResponderGrant` event.\n   */\n  scrollResponderHandleResponderGrant: function(e: Event) {\n    this.state.observedScrollSinceBecomingResponder = false;\n    this.props.onResponderGrant && this.props.onResponderGrant(e);\n    this.state.becameResponderWhileAnimating = this.scrollResponderIsAnimating();\n  },\n\n  /**\n   * Unfortunately, `onScrollBeginDrag` also fires when *stopping* the scroll\n   * animation, and there's not an easy way to distinguish a drag vs. stopping\n   * momentum.\n   *\n   * Invoke this from an `onScrollBeginDrag` event.\n   */\n  scrollResponderHandleScrollBeginDrag: function(e: Event) {\n    FrameRateLogger.beginScroll(); // TODO: track all scrolls after implementing onScrollEndAnimation\n    this.props.onScrollBeginDrag && this.props.onScrollBeginDrag(e);\n  },\n\n  /**\n   * Invoke this from an `onScrollEndDrag` event.\n   */\n  scrollResponderHandleScrollEndDrag: function(e: Event) {\n    const {velocity} = e.nativeEvent;\n    // - If we are animating, then this is a \"drag\" that is stopping the scrollview and momentum end\n    //   will fire.\n    // - If velocity is non-zero, then the interaction will stop when momentum scroll ends or\n    //   another drag starts and ends.\n    // - If we don't get velocity, better to stop the interaction twice than not stop it.\n    if (!this.scrollResponderIsAnimating() &&\n        (!velocity || velocity.x === 0 && velocity.y === 0)) {\n      FrameRateLogger.endScroll();\n    }\n    this.props.onScrollEndDrag && this.props.onScrollEndDrag(e);\n  },\n\n  /**\n   * Invoke this from an `onMomentumScrollBegin` event.\n   */\n  scrollResponderHandleMomentumScrollBegin: function(e: Event) {\n    this.state.lastMomentumScrollBeginTime = performanceNow();\n    this.props.onMomentumScrollBegin && this.props.onMomentumScrollBegin(e);\n  },\n\n  /**\n   * Invoke this from an `onMomentumScrollEnd` event.\n   */\n  scrollResponderHandleMomentumScrollEnd: function(e: Event) {\n    FrameRateLogger.endScroll();\n    this.state.lastMomentumScrollEndTime = performanceNow();\n    this.props.onMomentumScrollEnd && this.props.onMomentumScrollEnd(e);\n  },\n\n  /**\n   * Invoke this from an `onTouchStart` event.\n   *\n   * Since we know that the `SimpleEventPlugin` occurs later in the plugin\n   * order, after `ResponderEventPlugin`, we can detect that we were *not*\n   * permitted to be the responder (presumably because a contained view became\n   * responder). The `onResponderReject` won't fire in that case - it only\n   * fires when a *current* responder rejects our request.\n   *\n   * @param {SyntheticEvent} e Touch Start event.\n   */\n  scrollResponderHandleTouchStart: function(e: Event) {\n    this.state.isTouching = true;\n    this.props.onTouchStart && this.props.onTouchStart(e);\n  },\n\n  /**\n   * Invoke this from an `onTouchMove` event.\n   *\n   * Since we know that the `SimpleEventPlugin` occurs later in the plugin\n   * order, after `ResponderEventPlugin`, we can detect that we were *not*\n   * permitted to be the responder (presumably because a contained view became\n   * responder). The `onResponderReject` won't fire in that case - it only\n   * fires when a *current* responder rejects our request.\n   *\n   * @param {SyntheticEvent} e Touch Start event.\n   */\n  scrollResponderHandleTouchMove: function(e: Event) {\n    this.props.onTouchMove && this.props.onTouchMove(e);\n  },\n\n  /**\n   * A helper function for this class that lets us quickly determine if the\n   * view is currently animating. This is particularly useful to know when\n   * a touch has just started or ended.\n   */\n  scrollResponderIsAnimating: function(): boolean {\n    var now = performanceNow();\n    var timeSinceLastMomentumScrollEnd = now - this.state.lastMomentumScrollEndTime;\n    var isAnimating = timeSinceLastMomentumScrollEnd < IS_ANIMATING_TOUCH_START_THRESHOLD_MS ||\n      this.state.lastMomentumScrollEndTime < this.state.lastMomentumScrollBeginTime;\n    return isAnimating;\n  },\n\n  /**\n   * Returns the node that represents native view that can be scrolled.\n   * Components can pass what node to use by defining a `getScrollableNode`\n   * function otherwise `this` is used.\n   */\n  scrollResponderGetScrollableNode: function(): any {\n    return this.getScrollableNode ?\n      this.getScrollableNode() :\n      ReactNative.findNodeHandle(this);\n  },\n\n  /**\n   * A helper function to scroll to a specific point in the ScrollView.\n   * This is currently used to help focus child TextViews, but can also\n   * be used to quickly scroll to any element we want to focus. Syntax:\n   *\n   * `scrollResponderScrollTo(options: {x: number = 0; y: number = 0; animated: boolean = true})`\n   *\n   * Note: The weird argument signature is due to the fact that, for historical reasons,\n   * the function also accepts separate arguments as as alternative to the options object.\n   * This is deprecated due to ambiguity (y before x), and SHOULD NOT BE USED.\n   */\n  scrollResponderScrollTo: function(\n    x?: number | { x?: number, y?: number, animated?: boolean },\n    y?: number,\n    animated?: boolean\n  ) {\n    if (typeof x === 'number') {\n      console.warn('`scrollResponderScrollTo(x, y, animated)` is deprecated. Use `scrollResponderScrollTo({x: 5, y: 5, animated: true})` instead.');\n    } else {\n      ({x, y, animated} = x || {});\n    }\n    UIManager.dispatchViewManagerCommand(\n      nullthrows(this.scrollResponderGetScrollableNode()),\n      UIManager.RCTScrollView.Commands.scrollTo,\n      [x || 0, y || 0, animated !== false],\n    );\n  },\n\n  /**\n   * Scrolls to the end of the ScrollView, either immediately or with a smooth\n   * animation.\n   *\n   * Example:\n   *\n   * `scrollResponderScrollToEnd({animated: true})`\n   */\n  scrollResponderScrollToEnd: function(\n    options?: { animated?: boolean },\n  ) {\n    // Default to true\n    const animated = (options && options.animated) !== false;\n    UIManager.dispatchViewManagerCommand(\n      this.scrollResponderGetScrollableNode(),\n      UIManager.RCTScrollView.Commands.scrollToEnd,\n      [animated],\n    );\n  },\n\n  /**\n   * Deprecated, do not use.\n   */\n  scrollResponderScrollWithoutAnimationTo: function(offsetX: number, offsetY: number) {\n    console.warn('`scrollResponderScrollWithoutAnimationTo` is deprecated. Use `scrollResponderScrollTo` instead');\n    this.scrollResponderScrollTo({x: offsetX, y: offsetY, animated: false});\n  },\n\n  /**\n   * A helper function to zoom to a specific rect in the scrollview. The argument has the shape\n   * {x: number; y: number; width: number; height: number; animated: boolean = true}\n   *\n   * @platform ios\n   */\n  scrollResponderZoomTo: function(\n    rect: { x: number, y: number, width: number, height: number, animated?: boolean },\n    animated?: boolean // deprecated, put this inside the rect argument instead\n  ) {\n    invariant(ScrollViewManager && ScrollViewManager.zoomToRect, 'zoomToRect is not implemented');\n    if ('animated' in rect) {\n      var { animated, ...rect } = rect;\n    } else if (typeof animated !== 'undefined') {\n      console.warn('`scrollResponderZoomTo` `animated` argument is deprecated. Use `options.animated` instead');\n    }\n    ScrollViewManager.zoomToRect(this.scrollResponderGetScrollableNode(), rect, animated !== false);\n  },\n\n  /**\n   * Displays the scroll indicators momentarily.\n   */\n  scrollResponderFlashScrollIndicators: function() {\n    UIManager.dispatchViewManagerCommand(\n      this.scrollResponderGetScrollableNode(),\n      UIManager.RCTScrollView.Commands.flashScrollIndicators,\n      []\n    );\n  },\n\n  /**\n   * This method should be used as the callback to onFocus in a TextInputs'\n   * parent view. Note that any module using this mixin needs to return\n   * the parent view's ref in getScrollViewRef() in order to use this method.\n   * @param {any} nodeHandle The TextInput node handle\n   * @param {number} additionalOffset The scroll view's bottom \"contentInset\".\n   *        Default is 0.\n   * @param {bool} preventNegativeScrolling Whether to allow pulling the content\n   *        down to make it meet the keyboard's top. Default is false.\n   */\n  scrollResponderScrollNativeHandleToKeyboard: function(nodeHandle: any, additionalOffset?: number, preventNegativeScrollOffset?: bool) {\n    this.additionalScrollOffset = additionalOffset || 0;\n    this.preventNegativeScrollOffset = !!preventNegativeScrollOffset;\n    UIManager.measureLayout(\n      nodeHandle,\n      ReactNative.findNodeHandle(this.getInnerViewNode()),\n      this.scrollResponderTextInputFocusError,\n      this.scrollResponderInputMeasureAndScrollToKeyboard\n    );\n  },\n\n  /**\n   * The calculations performed here assume the scroll view takes up the entire\n   * screen - even if has some content inset. We then measure the offsets of the\n   * keyboard, and compensate both for the scroll view's \"contentInset\".\n   *\n   * @param {number} left Position of input w.r.t. table view.\n   * @param {number} top Position of input w.r.t. table view.\n   * @param {number} width Width of the text input.\n   * @param {number} height Height of the text input.\n   */\n  scrollResponderInputMeasureAndScrollToKeyboard: function(left: number, top: number, width: number, height: number) {\n    var keyboardScreenY = Dimensions.get('window').height;\n    if (this.keyboardWillOpenTo) {\n      keyboardScreenY = this.keyboardWillOpenTo.endCoordinates.screenY;\n    }\n    var scrollOffsetY = top - keyboardScreenY + height + this.additionalScrollOffset;\n\n    // By default, this can scroll with negative offset, pulling the content\n    // down so that the target component's bottom meets the keyboard's top.\n    // If requested otherwise, cap the offset at 0 minimum to avoid content\n    // shifting down.\n    if (this.preventNegativeScrollOffset) {\n      scrollOffsetY = Math.max(0, scrollOffsetY);\n    }\n    this.scrollResponderScrollTo({x: 0, y: scrollOffsetY, animated: true});\n\n    this.additionalOffset = 0;\n    this.preventNegativeScrollOffset = false;\n  },\n\n  scrollResponderTextInputFocusError: function(e: Event) {\n    console.error('Error measuring text field: ', e);\n  },\n\n  /**\n   * `componentWillMount` is the closest thing to a  standard \"constructor\" for\n   * React components.\n   *\n   * The `keyboardWillShow` is called before input focus.\n   */\n  componentWillMount: function() {\n    var {keyboardShouldPersistTaps} = this.props;\n    warning(\n      typeof keyboardShouldPersistTaps !== 'boolean',\n      `'keyboardShouldPersistTaps={${keyboardShouldPersistTaps}}' is deprecated. `\n      + `Use 'keyboardShouldPersistTaps=\"${keyboardShouldPersistTaps ? \"always\" : \"never\"}\"' instead`\n    );\n\n    this.keyboardWillOpenTo = null;\n    this.additionalScrollOffset = 0;\n    this.addListenerOn(Keyboard, 'keyboardWillShow', this.scrollResponderKeyboardWillShow);\n    this.addListenerOn(Keyboard, 'keyboardWillHide', this.scrollResponderKeyboardWillHide);\n    this.addListenerOn(Keyboard, 'keyboardDidShow', this.scrollResponderKeyboardDidShow);\n    this.addListenerOn(Keyboard, 'keyboardDidHide', this.scrollResponderKeyboardDidHide);\n  },\n\n  /**\n   * Warning, this may be called several times for a single keyboard opening.\n   * It's best to store the information in this method and then take any action\n   * at a later point (either in `keyboardDidShow` or other).\n   *\n   * Here's the order that events occur in:\n   * - focus\n   * - willShow {startCoordinates, endCoordinates} several times\n   * - didShow several times\n   * - blur\n   * - willHide {startCoordinates, endCoordinates} several times\n   * - didHide several times\n   *\n   * The `ScrollResponder` providesModule callbacks for each of these events.\n   * Even though any user could have easily listened to keyboard events\n   * themselves, using these `props` callbacks ensures that ordering of events\n   * is consistent - and not dependent on the order that the keyboard events are\n   * subscribed to. This matters when telling the scroll view to scroll to where\n   * the keyboard is headed - the scroll responder better have been notified of\n   * the keyboard destination before being instructed to scroll to where the\n   * keyboard will be. Stick to the `ScrollResponder` callbacks, and everything\n   * will work.\n   *\n   * WARNING: These callbacks will fire even if a keyboard is displayed in a\n   * different navigation pane. Filter out the events to determine if they are\n   * relevant to you. (For example, only if you receive these callbacks after\n   * you had explicitly focused a node etc).\n   */\n  scrollResponderKeyboardWillShow: function(e: Event) {\n    this.keyboardWillOpenTo = e;\n    this.props.onKeyboardWillShow && this.props.onKeyboardWillShow(e);\n  },\n\n  scrollResponderKeyboardWillHide: function(e: Event) {\n    this.keyboardWillOpenTo = null;\n    this.props.onKeyboardWillHide && this.props.onKeyboardWillHide(e);\n  },\n\n  scrollResponderKeyboardDidShow: function(e: Event) {\n    // TODO(7693961): The event for DidShow is not available on iOS yet.\n    // Use the one from WillShow and do not assign.\n    if (e) {\n      this.keyboardWillOpenTo = e;\n    }\n    this.props.onKeyboardDidShow && this.props.onKeyboardDidShow(e);\n  },\n\n  scrollResponderKeyboardDidHide: function(e: Event) {\n    this.keyboardWillOpenTo = null;\n    this.props.onKeyboardDidHide && this.props.onKeyboardDidHide(e);\n  }\n\n};\n\nvar ScrollResponder = {\n  Mixin: ScrollResponderMixin,\n};\n\nmodule.exports = ScrollResponder;\n"]}]