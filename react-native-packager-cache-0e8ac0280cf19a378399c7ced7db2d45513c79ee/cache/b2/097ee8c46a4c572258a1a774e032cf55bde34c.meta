["df7e9ef4f0baa6c3324f4169168f2c2d044d8375","f92ece8b244668f0864e6ae462c0ea91535dfda5",["MissingNativeEventEmitterShim","NativeEventEmitter","NativeModules","logError","fbjs/lib/invariant"],[60,127,178,262,299],{"version":3,"sources":["/Users/mani/Documents/Udacity/Core/React_Native/UdaciFitness/node_modules/react-native/Libraries/AppState/AppState.js"],"names":["MissingNativeEventEmitterShim","require","NativeEventEmitter","NativeModules","RCTAppState","AppState","logError","invariant","isAvailable","_eventHandlers","change","Map","memoryWarning","currentState","initialAppState","eventUpdated","addListener","appStateData","app_state","getCurrentAppState","type","handler","indexOf","set","has","get","remove","delete","__DEV__","MissingNativeAppStateShim","throwMissingNativeModule","module","exports"],"mappings":";AAWA;;AAEA,IAAMA,gCAAgCC,OAAhC,iCAAN;AACA,IAAMC,qBAAqBD,OAArB,sBAAN;AACA,IAAME,gBAAgBF,OAAhB,iBAAN;AACA,IAAMG,cAAcD,cAAcE,QAAlC;;AAEA,IAAMC,WAAWL,OAAX,YAAN;AACA,IAAMM,YAAYN,OAAZ,sBAAN;;IAkEMI,Q;;;AAMJ,sBAAc;AAAA;;AAAA,gIACND,WADM;;AAAA,UAFdI,WAEc,GAFS,IAET;;;AAGZ,UAAKA,WAAL,GAAmB,IAAnB;AACA,UAAKC,cAAL,GAAsB;AACpBC,cAAQ,IAAIC,GAAJ,EADY;AAEpBC,qBAAe,IAAID,GAAJ;AAFK,KAAtB;;AAOA,UAAKE,YAAL,GAAoBT,YAAYU,eAAZ,IAA+B,QAAnD;;AAEA,QAAIC,eAAe,KAAnB;;AAMA,UAAKC,WAAL,CACE,mBADF,EAEE,UAACC,YAAD,EAAkB;AAChBF,qBAAe,IAAf;AACA,YAAKF,YAAL,GAAoBI,aAAaC,SAAjC;AACD,KALH;;AAWAd,gBAAYe,kBAAZ,CACE,UAACF,YAAD,EAAkB;AAChB,UAAI,CAACF,YAAL,EAAmB;AACjB,cAAKF,YAAL,GAAoBI,aAAaC,SAAjC;AACD;AACF,KALH,EAMEZ,QANF;AA9BY;AAsCb;;;;qCAaCc,I,EACAC,O,EACA;AACAd,gBACE,CAAC,QAAD,EAAW,eAAX,EAA4Be,OAA5B,CAAoCF,IAApC,MAA8C,CAAC,CADjD,EAEE,4CAFF,EAEgDA,IAFhD;AAIA,UAAIA,SAAS,QAAb,EAAuB;AACrB,aAAKX,cAAL,CAAoBW,IAApB,EAA0BG,GAA1B,CAA8BF,OAA9B,EAAuC,KAAKL,WAAL,CACrC,mBADqC,EAErC,UAACC,YAAD,EAAkB;AAChBI,kBAAQJ,aAAaC,SAArB;AACD,SAJoC,CAAvC;AAMD,OAPD,MAOO,IAAIE,SAAS,eAAb,EAA8B;AACnC,aAAKX,cAAL,CAAoBW,IAApB,EAA0BG,GAA1B,CAA8BF,OAA9B,EAAuC,KAAKL,WAAL,CACrC,eADqC,EAErCK,OAFqC,CAAvC;AAID;AACF;;;wCAMCD,I,EACAC,O,EACA;AACAd,gBACE,CAAC,QAAD,EAAW,eAAX,EAA4Be,OAA5B,CAAoCF,IAApC,MAA8C,CAAC,CADjD,EAEE,mDAFF,EAEuDA,IAFvD;AAIA,UAAI,CAAC,KAAKX,cAAL,CAAoBW,IAApB,EAA0BI,GAA1B,CAA8BH,OAA9B,CAAL,EAA6C;AAC3C;AACD;AACD,WAAKZ,cAAL,CAAoBW,IAApB,EAA0BK,GAA1B,CAA8BJ,OAA9B,EAAuCK,MAAvC;AACA,WAAKjB,cAAL,CAAoBW,IAApB,EAA0BO,MAA1B,CAAiCN,OAAjC;AACD;;;EA/FoBnB,kB;;AAkGvB,IAAI0B,WAAW,CAACxB,WAAhB,EAA6B;AAAA,MACrByB,yBADqB;AAAA;;AAEzB,yCAAc;AAAA;AAAA,+JACN,aADM,EACS,UADT;AAEb;;AAJwB;AAAA;AAAA,yCAUa;AACpC,aAAKC,wBAAL;AACD;AAZwB;AAAA;AAAA,4CAcgB;AACvC,aAAKA,wBAAL;AACD;AAhBwB;AAAA;AAAA,0BAMG;AAC1B,aAAKA,wBAAL;AACD;AARwB;AAAA;AAAA,IACa9B,6BADb;;AAsB3BK,aAAW,IAAIwB,yBAAJ,EAAX;AACD,CAvBD,MAuBO;AACLxB,aAAW,IAAIA,QAAJ,EAAX;AACD;;AAED0B,OAAOC,OAAP,GAAiB3B,QAAjB","sourcesContent":["/**\n * Copyright (c) 2015-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule AppState\n * @flow\n */\n'use strict';\n\nconst MissingNativeEventEmitterShim = require('MissingNativeEventEmitterShim');\nconst NativeEventEmitter = require('NativeEventEmitter');\nconst NativeModules = require('NativeModules');\nconst RCTAppState = NativeModules.AppState;\n\nconst logError = require('logError');\nconst invariant = require('fbjs/lib/invariant');\n\n/**\n * `AppState` can tell you if the app is in the foreground or background,\n * and notify you when the state changes.\n *\n * AppState is frequently used to determine the intent and proper behavior when\n * handling push notifications.\n *\n * ### App States\n *\n *  - `active` - The app is running in the foreground\n *  - `background` - The app is running in the background. The user is either\n *     in another app or on the home screen\n *  - `inactive` - This is a state that occurs when transitioning between\n *     foreground & background, and during periods of inactivity such as\n *     entering the Multitasking view or in the event of an incoming call\n *\n * For more information, see\n * [Apple's documentation](https://developer.apple.com/library/ios/documentation/iPhone/Conceptual/iPhoneOSProgrammingGuide/TheAppLifeCycle/TheAppLifeCycle.html)\n *\n * ### Basic Usage\n *\n * To see the current state, you can check `AppState.currentState`, which\n * will be kept up-to-date. However, `currentState` will be null at launch\n * while `AppState` retrieves it over the bridge.\n *\n * ```\n * import React, {Component} from 'react'\n * import {AppState, Text} from 'react-native'\n *\n * class AppStateExample extends Component {\n *\n *   state = {\n *     appState: AppState.currentState\n *   }\n *\n *   componentDidMount() {\n *     AppState.addEventListener('change', this._handleAppStateChange);\n *   }\n *\n *   componentWillUnmount() {\n *     AppState.removeEventListener('change', this._handleAppStateChange);\n *   }\n *\n *   _handleAppStateChange = (nextAppState) => {\n *     if (this.state.appState.match(/inactive|background/) && nextAppState === 'active') {\n *       console.log('App has come to the foreground!')\n *     }\n *     this.setState({appState: nextAppState});\n *   }\n *\n *   render() {\n *     return (\n *       <Text>Current state is: {this.state.appState}</Text>\n *     );\n *   }\n *\n * }\n * ```\n *\n * This example will only ever appear to say \"Current state is: active\" because\n * the app is only visible to the user when in the `active` state, and the null\n * state will happen only momentarily.\n */\n\nclass AppState extends NativeEventEmitter {\n\n  _eventHandlers: Object;\n  currentState: ?string;\n  isAvailable: boolean = true;\n\n  constructor() {\n    super(RCTAppState);\n\n    this.isAvailable = true;\n    this._eventHandlers = {\n      change: new Map(),\n      memoryWarning: new Map(),\n    };\n\n    // TODO: Remove the 'active' fallback after `initialAppState` is exported by\n    // the Android implementation.\n    this.currentState = RCTAppState.initialAppState || 'active';\n\n    let eventUpdated = false;\n\n    // TODO: this is a terrible solution - in order to ensure `currentState` prop\n    // is up to date, we have to register an observer that updates it whenever\n    // the state changes, even if nobody cares. We should just deprecate the\n    // `currentState` property and get rid of this.\n    this.addListener(\n      'appStateDidChange',\n      (appStateData) => {\n        eventUpdated = true;\n        this.currentState = appStateData.app_state;\n      }\n    );\n\n    // TODO: see above - this request just populates the value of `currentState`\n    // when the module is first initialized. Would be better to get rid of the prop\n    // and expose `getCurrentAppState` method directly.\n    RCTAppState.getCurrentAppState(\n      (appStateData) => {\n        if (!eventUpdated) {\n          this.currentState = appStateData.app_state;\n        }\n      },\n      logError\n    );\n  }\n\n  /**\n   * Add a handler to AppState changes by listening to the `change` event type\n   * and providing the handler\n   *\n   * TODO: now that AppState is a subclass of NativeEventEmitter, we could deprecate\n   * `addEventListener` and `removeEventListener` and just use `addListener` and\n   * `listener.remove()` directly. That will be a breaking change though, as both\n   * the method and event names are different (addListener events are currently\n   * required to be globally unique).\n   */\n  addEventListener(\n    type: string,\n    handler: Function\n  ) {\n    invariant(\n      ['change', 'memoryWarning'].indexOf(type) !== -1,\n      'Trying to subscribe to unknown event: \"%s\"', type\n    );\n    if (type === 'change') {\n      this._eventHandlers[type].set(handler, this.addListener(\n        'appStateDidChange',\n        (appStateData) => {\n          handler(appStateData.app_state);\n        }\n      ));\n    } else if (type === 'memoryWarning') {\n      this._eventHandlers[type].set(handler, this.addListener(\n        'memoryWarning',\n        handler\n      ));\n    }\n  }\n\n  /**\n   * Remove a handler by passing the `change` event type and the handler\n   */\n  removeEventListener(\n    type: string,\n    handler: Function\n  ) {\n    invariant(\n      ['change', 'memoryWarning'].indexOf(type) !== -1,\n      'Trying to remove listener for unknown event: \"%s\"', type\n    );\n    if (!this._eventHandlers[type].has(handler)) {\n      return;\n    }\n    this._eventHandlers[type].get(handler).remove();\n    this._eventHandlers[type].delete(handler);\n  }\n}\n\nif (__DEV__ && !RCTAppState) {\n  class MissingNativeAppStateShim extends MissingNativeEventEmitterShim {\n    constructor() {\n      super('RCTAppState', 'AppState');\n    }\n\n    get currentState(): ?string {\n      this.throwMissingNativeModule();\n    }\n\n    addEventListener(...args: Array<any>) {\n      this.throwMissingNativeModule();\n    }\n\n    removeEventListener(...args: Array<any>) {\n      this.throwMissingNativeModule();\n    }\n  }\n\n  // This module depends on the native `RCTAppState` module. If you don't include it,\n  // `AppState.isAvailable` will return `false`, and any method calls will throw.\n  // We reassign the class variable to keep the autodoc generator happy.\n  AppState = new MissingNativeAppStateShim();\n} else {\n  AppState = new AppState();\n}\n\nmodule.exports = AppState;\n"]}]