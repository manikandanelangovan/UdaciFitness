["378d230994eb3338ed20c321acf564e7bf853970","890be8e40debe4dd8a396be01fdf79d513f4b58f",[],[],{"version":3,"sources":["/Users/mani/Documents/Udacity/Core/React_Native/UdaciFitness/node_modules/react-native/Libraries/Animated/src/bezier.js"],"names":["NEWTON_ITERATIONS","NEWTON_MIN_SLOPE","SUBDIVISION_PRECISION","SUBDIVISION_MAX_ITERATIONS","kSplineTableSize","kSampleStepSize","float32ArraySupported","Float32Array","A","aA1","aA2","B","C","calcBezier","aT","getSlope","binarySubdivide","aX","aA","aB","mX1","mX2","currentX","currentT","i","Math","abs","newtonRaphsonIterate","aGuessT","currentSlope","module","exports","bezier","mY1","mY2","Error","sampleValues","Array","getTForX","intervalStart","currentSample","lastSample","dist","guessForT","initialSlope","BezierEasing","x"],"mappings":"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","sourcesContent":["/**\n * BezierEasing - use bezier curve for transition easing function\n * https://github.com/gre/bezier-easing\n *\n * @copyright 2014-2015 GaÃ«tan Renaudeau. MIT License.\n * @providesModule bezier\n * @noflow\n */\n'use strict';\n\n // These values are established by empiricism with tests (tradeoff: performance VS precision)\n var NEWTON_ITERATIONS = 4;\n var NEWTON_MIN_SLOPE = 0.001;\n var SUBDIVISION_PRECISION = 0.0000001;\n var SUBDIVISION_MAX_ITERATIONS = 10;\n\n var kSplineTableSize = 11;\n var kSampleStepSize = 1.0 / (kSplineTableSize - 1.0);\n\n var float32ArraySupported = typeof Float32Array === 'function';\n\n function A (aA1, aA2) { return 1.0 - 3.0 * aA2 + 3.0 * aA1; }\n function B (aA1, aA2) { return 3.0 * aA2 - 6.0 * aA1; }\n function C (aA1)      { return 3.0 * aA1; }\n\n // Returns x(t) given t, x1, and x2, or y(t) given t, y1, and y2.\n function calcBezier (aT, aA1, aA2) { return ((A(aA1, aA2) * aT + B(aA1, aA2)) * aT + C(aA1)) * aT; }\n\n // Returns dx/dt given t, x1, and x2, or dy/dt given t, y1, and y2.\n function getSlope (aT, aA1, aA2) { return 3.0 * A(aA1, aA2) * aT * aT + 2.0 * B(aA1, aA2) * aT + C(aA1); }\n\n function binarySubdivide (aX, aA, aB, mX1, mX2) {\n   var currentX, currentT, i = 0;\n   do {\n     currentT = aA + (aB - aA) / 2.0;\n     currentX = calcBezier(currentT, mX1, mX2) - aX;\n     if (currentX > 0.0) {\n       aB = currentT;\n     } else {\n       aA = currentT;\n     }\n   } while (Math.abs(currentX) > SUBDIVISION_PRECISION && ++i < SUBDIVISION_MAX_ITERATIONS);\n   return currentT;\n }\n\n function newtonRaphsonIterate (aX, aGuessT, mX1, mX2) {\n  for (var i = 0; i < NEWTON_ITERATIONS; ++i) {\n    var currentSlope = getSlope(aGuessT, mX1, mX2);\n    if (currentSlope === 0.0) {\n      return aGuessT;\n    }\n    var currentX = calcBezier(aGuessT, mX1, mX2) - aX;\n    aGuessT -= currentX / currentSlope;\n  }\n  return aGuessT;\n }\n\n module.exports = function bezier (mX1, mY1, mX2, mY2) {\n   if (!(0 <= mX1 && mX1 <= 1 && 0 <= mX2 && mX2 <= 1)) { // eslint-disable-line yoda\n     throw new Error('bezier x values must be in [0, 1] range');\n   }\n\n   // Precompute samples table\n   var sampleValues = float32ArraySupported ? new Float32Array(kSplineTableSize) : new Array(kSplineTableSize);\n   if (mX1 !== mY1 || mX2 !== mY2) {\n     for (var i = 0; i < kSplineTableSize; ++i) {\n       sampleValues[i] = calcBezier(i * kSampleStepSize, mX1, mX2);\n     }\n   }\n\n   function getTForX (aX) {\n     var intervalStart = 0.0;\n     var currentSample = 1;\n     var lastSample = kSplineTableSize - 1;\n\n     for (; currentSample !== lastSample && sampleValues[currentSample] <= aX; ++currentSample) {\n       intervalStart += kSampleStepSize;\n     }\n     --currentSample;\n\n     // Interpolate to provide an initial guess for t\n     var dist = (aX - sampleValues[currentSample]) / (sampleValues[currentSample + 1] - sampleValues[currentSample]);\n     var guessForT = intervalStart + dist * kSampleStepSize;\n\n     var initialSlope = getSlope(guessForT, mX1, mX2);\n     if (initialSlope >= NEWTON_MIN_SLOPE) {\n       return newtonRaphsonIterate(aX, guessForT, mX1, mX2);\n     } else if (initialSlope === 0.0) {\n       return guessForT;\n     } else {\n       return binarySubdivide(aX, intervalStart, intervalStart + kSampleStepSize, mX1, mX2);\n     }\n   }\n\n   return function BezierEasing (x) {\n     if (mX1 === mY1 && mX2 === mY2) {\n       return x; // linear\n     }\n     // Because JavaScript number are imprecise, we should guarantee the extremes are right.\n     if (x === 0) {\n       return 0;\n     }\n     if (x === 1) {\n       return 1;\n     }\n     return calcBezier(getTForX(x), mY1, mY2);\n   };\n };\n"]}]