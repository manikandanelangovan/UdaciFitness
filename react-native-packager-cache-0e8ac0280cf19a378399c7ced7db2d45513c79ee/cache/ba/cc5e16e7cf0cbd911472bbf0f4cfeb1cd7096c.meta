["9479b5658e04be1cce8be5df37671237b749899f","26e7e6a72b7e9513c01d29a310934af01f07464c",["regenerator-runtime","react-native"],[49,102,160],{"version":3,"sources":["/Users/mani/Documents/Udacity/Core/React_Native/UdaciFitness/node_modules/expo/src/LegacyAsyncStorage.ios.js"],"names":["NativeModules","require","AsyncStorage","RCTAsyncStorage","ExponentLegacyAsyncLocalStorage","LegacyAsyncStorage","_getRequests","_getKeys","_immediate","migrateItems","items","force","isMigrationDone","multiGet","oldValuesArray","newValuesArray","newValuesMap","forEach","k","v","valuesToSet","filter","multiSet","setMigrationDone","getItem","key","callback","Promise","resolve","reject","errors","result","value","errs","convertErrors","getAllKeys","error","keys","convertError","flushGetRequests","getRequests","getKeys","map","reqLength","length","i","request","requestKeys","requestResult","setImmediate","getRequest","keyIndex","promiseResult","push","indexOf","Array","isArray","e","out","Error","message","module","exports"],"mappings":"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","sourcesContent":["/* eslint-disable */\n// Copyright 2015-present 650 Industries. All rights reserved.\n\n// Read-only access to legacy (unscoped) `RCTAsyncLocalStorage` backing for\n// access to legacy data, now that the new one we use in our fork is scoped\n// per-app\n\n// This code is basically based on react-native's built-in\n// `RCTAsyncStorage.js` except hardcoded to use\n// `ExponentLegacyAsyncLocalStorage` as the native module backing\n\n/**\n * Copyright (c) 2015-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n */\n'use strict';\n\nvar NativeModules = require('react-native').NativeModules;\nvar AsyncStorage = require('react-native').AsyncStorage;\n\n// Use RocksDB if available, then SQLite, then file storage.\nvar RCTAsyncStorage = NativeModules.ExponentLegacyAsyncLocalStorage;\n\n/**\n * @class\n * @description\n * `AsyncStorage` is a simple, unencrypted, asynchronous, persistent, key-value storage\n * system that is global to the app.  It should be used instead of LocalStorage.\n *\n * It is recommended that you use an abstraction on top of `AsyncStorage`\n * instead of `AsyncStorage` directly for anything more than light usage since\n * it operates globally.\n *\n * On iOS, `AsyncStorage` is backed by native code that stores small values in a\n * serialized dictionary and larger values in separate files. On Android,\n * `AsyncStorage` will use either [RocksDB](http://rocksdb.org/) or SQLite\n * based on what is available.\n *\n * The `AsyncStorage` JavaScript code is a simple facade that provides a clear\n * JavaScript API, real `Error` objects, and simple non-multi functions. Each\n * method in the API returns a `Promise` object.\n *\n * Persisting data:\n * ```\n * try {\n *   await AsyncStorage.setItem('@MySuperStore:key', 'I like to save it.');\n * } catch (error) {\n *   // Error saving data\n * }\n * ```\n *\n * Fetching data:\n * ```\n * try {\n *   const value = await AsyncStorage.getItem('@MySuperStore:key');\n *   if (value !== null){\n *     // We have data!!\n *     console.log(value);\n *   }\n * } catch (error) {\n *   // Error retrieving data\n * }\n * ```\n */\nvar LegacyAsyncStorage = {\n  _getRequests: ([]: Array<any>),\n  _getKeys: ([]: Array<string>),\n  _immediate: (null: ?number),\n\n  async migrateItems(items, { force = false } = {}) {\n    // Skip if already migrated and not forcing\n    if (!force && (await RCTAsyncStorage.isMigrationDone())) {\n      return;\n    }\n\n    // Get the old values\n    const oldValuesArray = await LegacyAsyncStorage.multiGet(items);\n\n    // Skip missing or newly set values\n    const newValuesArray = await AsyncStorage.multiGet(items);\n    const newValuesMap = {};\n    newValuesArray.forEach(([k, v]) => (newValuesMap[k] = v));\n    const valuesToSet = oldValuesArray.filter(\n      ([k, v]) => v !== null && newValuesMap[k] == null\n    );\n\n    // Migrate!\n    await AsyncStorage.multiSet(valuesToSet);\n    await RCTAsyncStorage.setMigrationDone();\n  },\n\n  /**\n   * Fetches an item for a `key` and invokes a callback upon completion.\n   * Returns a `Promise` object.\n   * @param key Key of the item to fetch.\n   * @param callback Function that will be called with a result if found or\n   *    any error.\n   * @returns A `Promise` object.\n   */\n  getItem(\n    key: string,\n    callback?: ?(error: ?Error, result: ?string) => void\n  ): Promise {\n    return new Promise((resolve, reject) => {\n      RCTAsyncStorage.multiGet([key], function(errors, result) {\n        // Unpack result to get value from [[key,value]]\n        var value = result && result[0] && result[0][1] ? result[0][1] : null;\n        var errs = convertErrors(errors);\n        callback && callback(errs && errs[0], value);\n        if (errs) {\n          reject(errs[0]);\n        } else {\n          resolve(value);\n        }\n      });\n    });\n  },\n\n  /**\n   * Gets *all* keys known to your app; for all callers, libraries, etc.\n   * Returns a `Promise` object.\n   * @param callback Function that will be called the keys found and any error.\n   * @returns A `Promise` object.\n   *\n   * Example: see the `multiGet` example.\n   */\n  getAllKeys(\n    callback?: ?(error: ?Error, keys: ?Array<string>) => void\n  ): Promise {\n    return new Promise((resolve, reject) => {\n      RCTAsyncStorage.getAllKeys(function(error, keys) {\n        callback && callback(convertError(error), keys);\n        if (error) {\n          reject(convertError(error));\n        } else {\n          resolve(keys);\n        }\n      });\n    });\n  },\n\n  /**\n   * The following batched functions are useful for executing a lot of\n   * operations at once, allowing for native optimizations and provide the\n   * convenience of a single callback after all operations are complete.\n   *\n   * These functions return arrays of errors, potentially one for every key.\n   * For key-specific errors, the Error object will have a key property to\n   * indicate which key caused the error.\n   */\n\n  /** Flushes any pending requests using a single batch call to get the data. */\n  flushGetRequests(): void {\n    const getRequests = this._getRequests;\n    const getKeys = this._getKeys;\n\n    this._getRequests = [];\n    this._getKeys = [];\n\n    RCTAsyncStorage.multiGet(getKeys, function(errors, result) {\n      // Even though the runtime complexity of this is theoretically worse vs if we used a map,\n      // it's much, much faster in practice for the data sets we deal with (we avoid\n      // allocating result pair arrays). This was heavily benchmarked.\n      //\n      // Is there a way to avoid using the map but fix the bug in this breaking test?\n      // https://github.com/facebook/react-native/commit/8dd8ad76579d7feef34c014d387bf02065692264\n      const map = {};\n      result &&\n        result.forEach(([key, value]) => {\n          map[key] = value;\n          return value;\n        });\n      const reqLength = getRequests.length;\n      for (let i = 0; i < reqLength; i++) {\n        const request = getRequests[i];\n        const requestKeys = request.keys;\n        const requestResult = requestKeys.map(key => [key, map[key]]);\n        request.callback && request.callback(null, requestResult);\n        request.resolve && request.resolve(requestResult);\n      }\n    });\n  },\n\n  /**\n   * This allows you to batch the fetching of items given an array of `key`\n   * inputs. Your callback will be invoked with an array of corresponding\n   * key-value pairs found:\n   *\n   * ```\n   * multiGet(['k1', 'k2'], cb) -> cb([['k1', 'val1'], ['k2', 'val2']])\n   * ```\n   *\n   * The method returns a `Promise` object.\n   *\n   * @param keys Array of key for the items to get.\n   * @param callback Function that will be called with a key-value array of\n   *     the results, plus an array of any key-specific errors found.\n   * @returns A `Promise` object.\n   *\n   * @example <caption>Example</caption>\n   *\n   * AsyncStorage.getAllKeys((err, keys) => {\n   *   AsyncStorage.multiGet(keys, (err, stores) => {\n   *    stores.map((result, i, store) => {\n   *      // get at each store's key/value so you can work with it\n   *      let key = store[i][0];\n   *      let value = store[i][1];\n   *     });\n   *   });\n   * });\n   */\n  multiGet(\n    keys: Array<string>,\n    callback?: ?(errors: ?Array<Error>, result: ?Array<Array<string>>) => void\n  ): Promise {\n    if (!this._immediate) {\n      this._immediate = setImmediate(() => {\n        this._immediate = null;\n        this.flushGetRequests();\n      });\n    }\n\n    var getRequest = {\n      keys,\n      callback,\n      // do we need this?\n      keyIndex: this._getKeys.length,\n      resolve: null,\n      reject: null,\n    };\n\n    var promiseResult = new Promise((resolve, reject) => {\n      getRequest.resolve = resolve;\n      getRequest.reject = reject;\n    });\n\n    this._getRequests.push(getRequest);\n    // avoid fetching duplicates\n    keys.forEach(key => {\n      if (this._getKeys.indexOf(key) === -1) {\n        this._getKeys.push(key);\n      }\n    });\n\n    return promiseResult;\n  },\n};\n\nfunction convertErrors(errs) {\n  if (!errs) {\n    return null;\n  }\n  return (Array.isArray(errs) ? errs : [errs]).map(e => convertError(e));\n}\n\nfunction convertError(error) {\n  if (!error) {\n    return null;\n  }\n  var out = new Error(error.message);\n  out.key = error.key; // flow doesn't like this :(\n  return out;\n}\n\nmodule.exports = LegacyAsyncStorage;\n"]}]