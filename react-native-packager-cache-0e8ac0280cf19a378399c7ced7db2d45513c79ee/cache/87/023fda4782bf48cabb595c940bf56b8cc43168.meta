["74b8371bfe726d37fe36dd14012065d4efca7808","38794ab57ff53e18d98aa4c81c9a903edfefc226",["Animated","I18nManager","PanResponder","React","prop-types","StyleSheet","react-timer-mixin","View","create-react-class","fbjs/lib/emptyFunction"],[39,78,121,158,192,232,272,313,354,405],{"version":3,"sources":["/Users/mani/Documents/Udacity/Core/React_Native/UdaciFitness/node_modules/react-native/Libraries/Experimental/SwipeableRow/SwipeableRow.js"],"names":["Animated","require","I18nManager","PanResponder","React","PropTypes","StyleSheet","TimerMixin","View","createReactClass","emptyFunction","IS_RTL","isRTL","CLOSED_LEFT_POSITION","HORIZONTAL_SWIPE_DISTANCE_THRESHOLD","HORIZONTAL_FULL_SWIPE_SPEED_THRESHOLD","SLOW_SPEED_SWIPE_FACTOR","SWIPE_DURATION","ON_MOUNT_BOUNCE_DELAY","ON_MOUNT_BOUNCE_DURATION","RIGHT_SWIPE_BOUNCE_BACK_DISTANCE","RIGHT_SWIPE_BOUNCE_BACK_DURATION","RIGHT_SWIPE_THRESHOLD","SwipeableRow","displayName","_panResponder","_previousLeft","mixins","propTypes","children","any","isOpen","bool","preventSwipeRight","maxSwipeDistance","number","isRequired","onOpen","func","onClose","onSwipeEnd","onSwipeStart","shouldBounceOnMount","slideoutView","node","swipeThreshold","getInitialState","currentLeft","Value","isSwipeableViewRendered","rowHeight","getDefaultProps","componentWillMount","create","onMoveShouldSetPanResponderCapture","_handleMoveShouldSetPanResponderCapture","onPanResponderGrant","_handlePanResponderGrant","onPanResponderMove","_handlePanResponderMove","onPanResponderRelease","_handlePanResponderEnd","onPanResponderTerminationRequest","_onPanResponderTerminationRequest","onPanResponderTerminate","onShouldBlockNativeResponder","event","gestureState","componentDidMount","props","setTimeout","_animateBounceBack","componentWillReceiveProps","nextProps","_animateToClosedPosition","shouldComponentUpdate","nextState","render","slideOutView","state","styles","slideOutContainer","height","swipeableView","_onSwipeableViewLayout","transform","translateX","panHandlers","close","setState","nativeEvent","layout","dy","_isValidSwipe","_isSwipingExcessivelyRightFromClosedPosition","_isSwipingRightFromClosed","_swipeSlowSpeed","_swipeFullSpeed","gestureStateDx","dx","setValue","_animateTo","toValue","duration","callback","timing","useNativeDriver","start","_animateToOpenPosition","_animateToOpenPositionWith","speed","distMoved","Math","abs","_animateToClosedPositionDuringBounce","swipeBounceBackDistance","_shouldAnimateRemainder","vx","horizontalDistance","bottom","left","position","right","top","module","exports"],"mappings":"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","sourcesContent":["/**\n * Copyright (c) 2015-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule SwipeableRow\n * @flow\n */\n'use strict';\n\nconst Animated = require('Animated');\nconst I18nManager = require('I18nManager');\nconst PanResponder = require('PanResponder');\nconst React = require('React');\nconst PropTypes = require('prop-types');\nconst StyleSheet = require('StyleSheet');\nconst TimerMixin = require('react-timer-mixin');\nconst View = require('View');\n\nconst createReactClass = require('create-react-class');\nconst emptyFunction = require('fbjs/lib/emptyFunction');\n\nconst IS_RTL = I18nManager.isRTL;\n\n// NOTE: Eventually convert these consts to an input object of configurations\n\n// Position of the left of the swipable item when closed\nconst CLOSED_LEFT_POSITION = 0;\n// Minimum swipe distance before we recognize it as such\nconst HORIZONTAL_SWIPE_DISTANCE_THRESHOLD = 10;\n// Minimum swipe speed before we fully animate the user's action (open/close)\nconst HORIZONTAL_FULL_SWIPE_SPEED_THRESHOLD = 0.3;\n// Factor to divide by to get slow speed; i.e. 4 means 1/4 of full speed\nconst SLOW_SPEED_SWIPE_FACTOR = 4;\n// Time, in milliseconds, of how long the animated swipe should be\nconst SWIPE_DURATION = 300;\n\n/**\n * On SwipeableListView mount, the 1st item will bounce to show users it's\n * possible to swipe\n */\nconst ON_MOUNT_BOUNCE_DELAY = 700;\nconst ON_MOUNT_BOUNCE_DURATION = 400;\n\n// Distance left of closed position to bounce back when right-swiping from closed\nconst RIGHT_SWIPE_BOUNCE_BACK_DISTANCE = 30;\nconst RIGHT_SWIPE_BOUNCE_BACK_DURATION = 300;\n/**\n * Max distance of right swipe to allow (right swipes do functionally nothing).\n * Must be multiplied by SLOW_SPEED_SWIPE_FACTOR because gestureState.dx tracks\n * how far the finger swipes, and not the actual animation distance.\n*/\nconst RIGHT_SWIPE_THRESHOLD = 30 * SLOW_SPEED_SWIPE_FACTOR;\n\n/**\n * Creates a swipable row that allows taps on the main item and a custom View\n * on the item hidden behind the row. Typically this should be used in\n * conjunction with SwipeableListView for additional functionality, but can be\n * used in a normal ListView. See the renderRow for SwipeableListView to see how\n * to use this component separately.\n */\nconst SwipeableRow = createReactClass({\n  displayName: 'SwipeableRow',\n  _panResponder: {},\n  _previousLeft: CLOSED_LEFT_POSITION,\n\n  mixins: [TimerMixin],\n\n  propTypes: {\n    children: PropTypes.any,\n    isOpen: PropTypes.bool,\n    preventSwipeRight: PropTypes.bool,\n    maxSwipeDistance: PropTypes.number.isRequired,\n    onOpen: PropTypes.func.isRequired,\n    onClose: PropTypes.func.isRequired,\n    onSwipeEnd: PropTypes.func.isRequired,\n    onSwipeStart: PropTypes.func.isRequired,\n    // Should bounce the row on mount\n    shouldBounceOnMount: PropTypes.bool,\n    /**\n     * A ReactElement that is unveiled when the user swipes\n     */\n    slideoutView: PropTypes.node.isRequired,\n    /**\n     * The minimum swipe distance required before fully animating the swipe. If\n     * the user swipes less than this distance, the item will return to its\n     * previous (open/close) position.\n     */\n    swipeThreshold: PropTypes.number.isRequired,\n  },\n\n  getInitialState(): Object {\n    return {\n      currentLeft: new Animated.Value(this._previousLeft),\n      /**\n       * In order to render component A beneath component B, A must be rendered\n       * before B. However, this will cause \"flickering\", aka we see A briefly\n       * then B. To counter this, _isSwipeableViewRendered flag is used to set\n       * component A to be transparent until component B is loaded.\n       */\n      isSwipeableViewRendered: false,\n      rowHeight: (null: ?number),\n    };\n  },\n\n  getDefaultProps(): Object {\n    return {\n      isOpen: false,\n      preventSwipeRight: false,\n      maxSwipeDistance: 0,\n      onOpen: emptyFunction,\n      onClose: emptyFunction,\n      onSwipeEnd: emptyFunction,\n      onSwipeStart: emptyFunction,\n      swipeThreshold: 30,\n    };\n  },\n\n  componentWillMount(): void {\n    this._panResponder = PanResponder.create({\n      onMoveShouldSetPanResponderCapture: this._handleMoveShouldSetPanResponderCapture,\n      onPanResponderGrant: this._handlePanResponderGrant,\n      onPanResponderMove: this._handlePanResponderMove,\n      onPanResponderRelease: this._handlePanResponderEnd,\n      onPanResponderTerminationRequest: this._onPanResponderTerminationRequest,\n      onPanResponderTerminate: this._handlePanResponderEnd,\n      onShouldBlockNativeResponder: (event, gestureState) => false,\n    });\n  },\n\n  componentDidMount(): void {\n    if (this.props.shouldBounceOnMount) {\n      /**\n       * Do the on mount bounce after a delay because if we animate when other\n       * components are loading, the animation will be laggy\n       */\n      this.setTimeout(() => {\n        this._animateBounceBack(ON_MOUNT_BOUNCE_DURATION);\n      }, ON_MOUNT_BOUNCE_DELAY);\n    }\n  },\n\n  componentWillReceiveProps(nextProps: Object): void {\n    /**\n     * We do not need an \"animateOpen(noCallback)\" because this animation is\n     * handled internally by this component.\n     */\n    if (this.props.isOpen && !nextProps.isOpen) {\n      this._animateToClosedPosition();\n    }\n  },\n\n  shouldComponentUpdate(nextProps: Object, nextState: Object): boolean {\n    if (this.props.shouldBounceOnMount && !nextProps.shouldBounceOnMount) {\n      // No need to rerender if SwipeableListView is disabling the bounce flag\n      return false;\n    }\n\n    return true;\n  },\n\n  render(): React.Element<any> {\n    // The view hidden behind the main view\n    let slideOutView;\n    if (this.state.isSwipeableViewRendered && this.state.rowHeight) {\n      slideOutView = (\n        <View style={[\n          styles.slideOutContainer,\n          {height: this.state.rowHeight},\n          ]}>\n          {this.props.slideoutView}\n        </View>\n      );\n    }\n\n    // The swipeable item\n    const swipeableView = (\n      <Animated.View\n        onLayout={this._onSwipeableViewLayout}\n        style={{transform: [{translateX: this.state.currentLeft}]}}>\n        {this.props.children}\n      </Animated.View>\n    );\n\n    return (\n      <View\n        {...this._panResponder.panHandlers}>\n        {slideOutView}\n        {swipeableView}\n      </View>\n    );\n  },\n\n  close(): void {\n    this.props.onClose();\n    this._animateToClosedPosition();\n  },\n\n  _onSwipeableViewLayout(event: Object): void {\n    this.setState({\n      isSwipeableViewRendered: true,\n      rowHeight: event.nativeEvent.layout.height,\n    });\n  },\n\n  _handleMoveShouldSetPanResponderCapture(\n    event: Object,\n    gestureState: Object,\n  ): boolean {\n    // Decides whether a swipe is responded to by this component or its child\n    return gestureState.dy < 10 && this._isValidSwipe(gestureState);\n  },\n\n  _handlePanResponderGrant(event: Object, gestureState: Object): void {\n\n  },\n\n  _handlePanResponderMove(event: Object, gestureState: Object): void {\n    if (this._isSwipingExcessivelyRightFromClosedPosition(gestureState)) {\n      return;\n    }\n\n    this.props.onSwipeStart();\n\n    if (this._isSwipingRightFromClosed(gestureState)) {\n      this._swipeSlowSpeed(gestureState);\n    } else {\n      this._swipeFullSpeed(gestureState);\n    }\n  },\n\n  _isSwipingRightFromClosed(gestureState: Object): boolean {\n    const gestureStateDx = IS_RTL ? -gestureState.dx : gestureState.dx;\n    return this._previousLeft === CLOSED_LEFT_POSITION && gestureStateDx > 0;\n  },\n\n  _swipeFullSpeed(gestureState: Object): void {\n    this.state.currentLeft.setValue(this._previousLeft + gestureState.dx);\n  },\n\n  _swipeSlowSpeed(gestureState: Object): void {\n    this.state.currentLeft.setValue(\n      this._previousLeft + gestureState.dx / SLOW_SPEED_SWIPE_FACTOR,\n    );\n  },\n\n  _isSwipingExcessivelyRightFromClosedPosition(gestureState: Object): boolean {\n    /**\n     * We want to allow a BIT of right swipe, to allow users to know that\n     * swiping is available, but swiping right does not do anything\n     * functionally.\n     */\n    const gestureStateDx = IS_RTL ? -gestureState.dx : gestureState.dx;\n    return (\n      this._isSwipingRightFromClosed(gestureState) &&\n      gestureStateDx > RIGHT_SWIPE_THRESHOLD\n    );\n  },\n\n  _onPanResponderTerminationRequest(\n    event: Object,\n    gestureState: Object,\n  ): boolean {\n    return false;\n  },\n\n  _animateTo(\n    toValue: number,\n    duration: number = SWIPE_DURATION,\n    callback: Function = emptyFunction,\n  ): void {\n    Animated.timing(\n      this.state.currentLeft,\n      {\n        duration,\n        toValue,\n        useNativeDriver: true,\n      },\n    ).start(() => {\n      this._previousLeft = toValue;\n      callback();\n    });\n  },\n\n  _animateToOpenPosition(): void {\n    const maxSwipeDistance = IS_RTL ? -this.props.maxSwipeDistance : this.props.maxSwipeDistance;\n    this._animateTo(-maxSwipeDistance);\n  },\n\n  _animateToOpenPositionWith(\n    speed: number,\n    distMoved: number,\n  ): void {\n    /**\n     * Ensure the speed is at least the set speed threshold to prevent a slow\n     * swiping animation\n     */\n    speed = (\n      speed > HORIZONTAL_FULL_SWIPE_SPEED_THRESHOLD ?\n      speed :\n      HORIZONTAL_FULL_SWIPE_SPEED_THRESHOLD\n    );\n    /**\n     * Calculate the duration the row should take to swipe the remaining distance\n     * at the same speed the user swiped (or the speed threshold)\n     */\n    const duration = Math.abs((this.props.maxSwipeDistance - Math.abs(distMoved)) / speed);\n    const maxSwipeDistance = IS_RTL ? -this.props.maxSwipeDistance : this.props.maxSwipeDistance;\n    this._animateTo(-maxSwipeDistance, duration);\n  },\n\n  _animateToClosedPosition(duration: number = SWIPE_DURATION): void {\n    this._animateTo(CLOSED_LEFT_POSITION, duration);\n  },\n\n  _animateToClosedPositionDuringBounce(): void {\n    this._animateToClosedPosition(RIGHT_SWIPE_BOUNCE_BACK_DURATION);\n  },\n\n  _animateBounceBack(duration: number): void {\n    /**\n     * When swiping right, we want to bounce back past closed position on release\n     * so users know they should swipe right to get content.\n     */\n    const swipeBounceBackDistance = IS_RTL ?\n      -RIGHT_SWIPE_BOUNCE_BACK_DISTANCE :\n      RIGHT_SWIPE_BOUNCE_BACK_DISTANCE;\n    this._animateTo(\n      -swipeBounceBackDistance,\n      duration,\n      this._animateToClosedPositionDuringBounce,\n    );\n  },\n\n  // Ignore swipes due to user's finger moving slightly when tapping\n  _isValidSwipe(gestureState: Object): boolean {\n    if (this.props.preventSwipeRight && this._previousLeft === CLOSED_LEFT_POSITION && gestureState.dx > 0) {\n      return false;\n    }\n\n    return Math.abs(gestureState.dx) > HORIZONTAL_SWIPE_DISTANCE_THRESHOLD;\n  },\n\n  _shouldAnimateRemainder(gestureState: Object): boolean {\n    /**\n     * If user has swiped past a certain distance, animate the rest of the way\n     * if they let go\n     */\n    return (\n      Math.abs(gestureState.dx) > this.props.swipeThreshold ||\n      gestureState.vx > HORIZONTAL_FULL_SWIPE_SPEED_THRESHOLD\n    );\n  },\n\n  _handlePanResponderEnd(event: Object, gestureState: Object): void {\n    const horizontalDistance = IS_RTL ? -gestureState.dx : gestureState.dx;\n    if (this._isSwipingRightFromClosed(gestureState)) {\n      this.props.onOpen();\n      this._animateBounceBack(RIGHT_SWIPE_BOUNCE_BACK_DURATION);\n    } else if (this._shouldAnimateRemainder(gestureState)) {\n      if (horizontalDistance < 0) {\n        // Swiped left\n        this.props.onOpen();\n        this._animateToOpenPositionWith(gestureState.vx, horizontalDistance);\n      } else {\n        // Swiped right\n        this.props.onClose();\n        this._animateToClosedPosition();\n      }\n    } else {\n      if (this._previousLeft === CLOSED_LEFT_POSITION) {\n        this._animateToClosedPosition();\n      } else {\n        this._animateToOpenPosition();\n      }\n    }\n\n    this.props.onSwipeEnd();\n  },\n});\n\nconst styles = StyleSheet.create({\n  slideOutContainer: {\n    bottom: 0,\n    left: 0,\n    position: 'absolute',\n    right: 0,\n    top: 0,\n  },\n});\n\nmodule.exports = SwipeableRow;\n"]}]