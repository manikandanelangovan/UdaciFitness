["cf06def0f1a57b2c95a81a35747edcf93c3b0642","0aedec1346fd53632a8b808a1d7924cee25b0d45",["NativeModules"],[44],{"version":3,"sources":["/Users/mani/Documents/Udacity/Core/React_Native/UdaciFitness/node_modules/react-native/Libraries/Storage/AsyncStorage.js"],"names":["NativeModules","require","RCTAsyncStorage","AsyncRocksDBStorage","AsyncSQLiteDBStorage","AsyncLocalStorage","AsyncStorage","_getRequests","_getKeys","_immediate","getItem","key","callback","Promise","resolve","reject","multiGet","errors","result","value","errs","convertErrors","setItem","multiSet","removeItem","multiRemove","mergeItem","multiMerge","clear","error","convertError","getAllKeys","keys","flushGetRequests","getRequests","getKeys","map","forEach","reqLength","length","i","request","requestKeys","requestResult","setImmediate","getRequest","keyIndex","promiseResult","push","indexOf","keyValuePairs","Array","isArray","e","out","Error","message","module","exports"],"mappings":"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","sourcesContent":["/**\n * Copyright (c) 2015-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule AsyncStorage\n * @noflow\n * @flow-weak\n * @jsdoc\n */\n'use strict';\n\nconst NativeModules = require('NativeModules');\n\n// Use RocksDB if available, then SQLite, then file storage.\nconst RCTAsyncStorage = NativeModules.AsyncRocksDBStorage ||\n  NativeModules.AsyncSQLiteDBStorage ||\n  NativeModules.AsyncLocalStorage;\n\n/**\n * @class\n * @description\n * `AsyncStorage` is a simple, unencrypted, asynchronous, persistent, key-value storage\n * system that is global to the app.  It should be used instead of LocalStorage.\n *\n * It is recommended that you use an abstraction on top of `AsyncStorage`\n * instead of `AsyncStorage` directly for anything more than light usage since\n * it operates globally.\n *\n * On iOS, `AsyncStorage` is backed by native code that stores small values in a\n * serialized dictionary and larger values in separate files. On Android,\n * `AsyncStorage` will use either [RocksDB](http://rocksdb.org/) or SQLite\n * based on what is available.\n *\n * The `AsyncStorage` JavaScript code is a simple facade that provides a clear\n * JavaScript API, real `Error` objects, and simple non-multi functions. Each\n * method in the API returns a `Promise` object.\n *\n * Persisting data:\n * ```\n * try {\n *   await AsyncStorage.setItem('@MySuperStore:key', 'I like to save it.');\n * } catch (error) {\n *   // Error saving data\n * }\n * ```\n *\n * Fetching data:\n * ```\n * try {\n *   const value = await AsyncStorage.getItem('@MySuperStore:key');\n *   if (value !== null){\n *     // We have data!!\n *     console.log(value);\n *   }\n * } catch (error) {\n *   // Error retrieving data\n * }\n * ```\n */\nvar AsyncStorage = {\n  _getRequests: ([]: Array<any>),\n  _getKeys: ([]: Array<string>),\n  _immediate: (null: ?number),\n\n  /**\n   * Fetches an item for a `key` and invokes a callback upon completion.\n   * Returns a `Promise` object.\n   * @param key Key of the item to fetch.\n   * @param callback Function that will be called with a result if found or\n   *    any error.\n   * @returns A `Promise` object.\n   */\n  getItem: function(\n    key: string,\n    callback?: ?(error: ?Error, result: ?string) => void\n  ): Promise {\n    return new Promise((resolve, reject) => {\n      RCTAsyncStorage.multiGet([key], function(errors, result) {\n        // Unpack result to get value from [[key,value]]\n        var value = (result && result[0] && result[0][1]) ? result[0][1] : null;\n        var errs = convertErrors(errors);\n        callback && callback(errs && errs[0], value);\n        if (errs) {\n          reject(errs[0]);\n        } else {\n          resolve(value);\n        }\n      });\n    });\n  },\n\n  /**\n   * Sets the value for a `key` and invokes a callback upon completion.\n   * Returns a `Promise` object.\n   * @param key Key of the item to set.\n   * @param value Value to set for the `key`.\n   * @param callback Function that will be called with any error.\n   * @returns A `Promise` object.\n   */\n  setItem: function(\n    key: string,\n    value: string,\n    callback?: ?(error: ?Error) => void\n  ): Promise {\n    return new Promise((resolve, reject) => {\n      RCTAsyncStorage.multiSet([[key,value]], function(errors) {\n        var errs = convertErrors(errors);\n        callback && callback(errs && errs[0]);\n        if (errs) {\n          reject(errs[0]);\n        } else {\n          resolve(null);\n        }\n      });\n    });\n  },\n\n  /**\n   * Removes an item for a `key` and invokes a callback upon completion.\n   * Returns a `Promise` object.\n   * @param key Key of the item to remove.\n   * @param callback Function that will be called with any error.\n   * @returns A `Promise` object.\n   */\n  removeItem: function(\n    key: string,\n    callback?: ?(error: ?Error) => void\n  ): Promise {\n    return new Promise((resolve, reject) => {\n      RCTAsyncStorage.multiRemove([key], function(errors) {\n        var errs = convertErrors(errors);\n        callback && callback(errs && errs[0]);\n        if (errs) {\n          reject(errs[0]);\n        } else {\n          resolve(null);\n        }\n      });\n    });\n  },\n\n  /**\n   * Merges an existing `key` value with an input value, assuming both values\n   * are stringified JSON. Returns a `Promise` object.\n   *\n   * **NOTE:** This is not supported by all native implementations.\n   *\n   * @param key Key of the item to modify.\n   * @param value New value to merge for the `key`.\n   * @param callback Function that will be called with any error.\n   * @returns A `Promise` object.\n   *\n   * @example <caption>Example</caption>\n   * let UID123_object = {\n   *  name: 'Chris',\n   *  age: 30,\n   *  traits: {hair: 'brown', eyes: 'brown'},\n   * };\n   * // You only need to define what will be added or updated\n   * let UID123_delta = {\n   *  age: 31,\n   *  traits: {eyes: 'blue', shoe_size: 10}\n   * };\n   *\n   * AsyncStorage.setItem('UID123', JSON.stringify(UID123_object), () => {\n   *   AsyncStorage.mergeItem('UID123', JSON.stringify(UID123_delta), () => {\n   *     AsyncStorage.getItem('UID123', (err, result) => {\n   *       console.log(result);\n   *     });\n   *   });\n   * });\n   *\n   * // Console log result:\n   * // => {'name':'Chris','age':31,'traits':\n   * //    {'shoe_size':10,'hair':'brown','eyes':'blue'}}\n   */\n  mergeItem: function(\n    key: string,\n    value: string,\n    callback?: ?(error: ?Error) => void\n  ): Promise {\n    return new Promise((resolve, reject) => {\n      RCTAsyncStorage.multiMerge([[key,value]], function(errors) {\n        var errs = convertErrors(errors);\n        callback && callback(errs && errs[0]);\n        if (errs) {\n          reject(errs[0]);\n        } else {\n          resolve(null);\n        }\n      });\n    });\n  },\n\n  /**\n   * Erases *all* `AsyncStorage` for all clients, libraries, etc.  You probably\n   * don't want to call this; use `removeItem` or `multiRemove` to clear only\n   * your app's keys. Returns a `Promise` object.\n   * @param callback Function that will be called with any error.\n   * @returns A `Promise` object.\n   */\n  clear: function(callback?: ?(error: ?Error) => void): Promise {\n    return new Promise((resolve, reject) => {\n      RCTAsyncStorage.clear(function(error) {\n        callback && callback(convertError(error));\n        if (error && convertError(error)){\n          reject(convertError(error));\n        } else {\n          resolve(null);\n        }\n      });\n    });\n  },\n\n  /**\n   * Gets *all* keys known to your app; for all callers, libraries, etc.\n   * Returns a `Promise` object.\n   * @param callback Function that will be called the keys found and any error.\n   * @returns A `Promise` object.\n   *\n   * Example: see the `multiGet` example.\n   */\n  getAllKeys: function(callback?: ?(error: ?Error, keys: ?Array<string>) => void): Promise {\n    return new Promise((resolve, reject) => {\n      RCTAsyncStorage.getAllKeys(function(error, keys) {\n        callback && callback(convertError(error), keys);\n        if (error) {\n          reject(convertError(error));\n        } else {\n          resolve(keys);\n        }\n      });\n    });\n  },\n\n  /**\n   * The following batched functions are useful for executing a lot of\n   * operations at once, allowing for native optimizations and provide the\n   * convenience of a single callback after all operations are complete.\n   *\n   * These functions return arrays of errors, potentially one for every key.\n   * For key-specific errors, the Error object will have a key property to\n   * indicate which key caused the error.\n   */\n\n  /** Flushes any pending requests using a single batch call to get the data. */\n  flushGetRequests: function(): void {\n    const getRequests = this._getRequests;\n    const getKeys = this._getKeys;\n\n    this._getRequests = [];\n    this._getKeys = [];\n\n    RCTAsyncStorage.multiGet(getKeys, function(errors, result) {\n      // Even though the runtime complexity of this is theoretically worse vs if we used a map,\n      // it's much, much faster in practice for the data sets we deal with (we avoid\n      // allocating result pair arrays). This was heavily benchmarked.\n      //\n      // Is there a way to avoid using the map but fix the bug in this breaking test?\n      // https://github.com/facebook/react-native/commit/8dd8ad76579d7feef34c014d387bf02065692264\n      const map = {};\n      result && result.forEach(([key, value]) => { map[key] = value; return value; });\n      const reqLength = getRequests.length;\n      for (let i = 0; i < reqLength; i++) {\n        const request = getRequests[i];\n        const requestKeys = request.keys;\n        const requestResult = requestKeys.map(key => [key, map[key]]);\n        request.callback && request.callback(null, requestResult);\n        request.resolve && request.resolve(requestResult);\n      }\n    });\n  },\n\n  /**\n   * This allows you to batch the fetching of items given an array of `key`\n   * inputs. Your callback will be invoked with an array of corresponding\n   * key-value pairs found:\n   *\n   * ```\n   * multiGet(['k1', 'k2'], cb) -> cb([['k1', 'val1'], ['k2', 'val2']])\n   * ```\n   *\n   * The method returns a `Promise` object.\n   *\n   * @param keys Array of key for the items to get.\n   * @param callback Function that will be called with a key-value array of\n   *     the results, plus an array of any key-specific errors found.\n   * @returns A `Promise` object.\n   *\n   * @example <caption>Example</caption>\n   *\n   * AsyncStorage.getAllKeys((err, keys) => {\n   *   AsyncStorage.multiGet(keys, (err, stores) => {\n   *    stores.map((result, i, store) => {\n   *      // get at each store's key/value so you can work with it\n   *      let key = store[i][0];\n   *      let value = store[i][1];\n   *     });\n   *   });\n   * });\n   */\n  multiGet: function(\n    keys: Array<string>,\n    callback?: ?(errors: ?Array<Error>, result: ?Array<Array<string>>) => void\n  ): Promise {\n    if (!this._immediate) {\n      this._immediate = setImmediate(() => {\n        this._immediate = null;\n        this.flushGetRequests();\n      });\n    }\n\n    var getRequest = {\n      keys: keys,\n      callback: callback,\n      // do we need this?\n      keyIndex: this._getKeys.length,\n      resolve: null,\n      reject: null,\n    };\n\n    var promiseResult = new Promise((resolve, reject) => {\n      getRequest.resolve = resolve;\n      getRequest.reject = reject;\n    });\n\n    this._getRequests.push(getRequest);\n    // avoid fetching duplicates\n    keys.forEach(key => {\n      if (this._getKeys.indexOf(key) === -1) {\n        this._getKeys.push(key);\n      }\n    });\n\n    return promiseResult;\n  },\n\n  /**\n   * Use this as a batch operation for storing multiple key-value pairs. When\n   * the operation completes you'll get a single callback with any errors:\n   *\n   * ```\n   * multiSet([['k1', 'val1'], ['k2', 'val2']], cb);\n   * ```\n   *\n   * The method returns a `Promise` object.\n   *\n   * @param keyValuePairs Array of key-value array for the items to set.\n   * @param callback Function that will be called with an array of any\n   *    key-specific errors found.\n   * @returns A `Promise` object.\n   * Example: see the `multiMerge` example.\n   */\n  multiSet: function(\n    keyValuePairs: Array<Array<string>>,\n    callback?: ?(errors: ?Array<Error>) => void\n  ): Promise {\n    return new Promise((resolve, reject) => {\n      RCTAsyncStorage.multiSet(keyValuePairs, function(errors) {\n        var error = convertErrors(errors);\n        callback && callback(error);\n        if (error) {\n          reject(error);\n        } else {\n          resolve(null);\n        }\n      });\n    });\n  },\n\n  /**\n   * Call this to batch the deletion of all keys in the `keys` array. Returns\n   * a `Promise` object.\n   *\n   * @param keys Array of key for the items to delete.\n   * @param callback Function that will be called an array of any key-specific\n   *    errors found.\n   * @returns A `Promise` object.\n   *\n   * @example <caption>Example</caption>\n   * let keys = ['k1', 'k2'];\n   * AsyncStorage.multiRemove(keys, (err) => {\n   *   // keys k1 & k2 removed, if they existed\n   *   // do most stuff after removal (if you want)\n   * });\n   */\n  multiRemove: function(\n    keys: Array<string>,\n    callback?: ?(errors: ?Array<Error>) => void\n  ): Promise {\n    return new Promise((resolve, reject) => {\n      RCTAsyncStorage.multiRemove(keys, function(errors) {\n        var error = convertErrors(errors);\n        callback && callback(error);\n        if (error) {\n          reject(error);\n        } else {\n          resolve(null);\n        }\n      });\n    });\n  },\n\n  /**\n   * Batch operation to merge in existing and new values for a given set of\n   * keys. This assumes that the values are stringified JSON. Returns a\n   * `Promise` object.\n   *\n   * **NOTE**: This is not supported by all native implementations.\n   *\n   * @param keyValuePairs Array of key-value array for the items to merge.\n   * @param callback Function that will be called with an array of any\n   *    key-specific errors found.\n   * @returns A `Promise` object.\n   *\n   * @example <caption>Example</caption>\n   * // first user, initial values\n   * let UID234_object = {\n   *  name: 'Chris',\n   *  age: 30,\n   *  traits: {hair: 'brown', eyes: 'brown'},\n   * };\n   *\n   * // first user, delta values\n   * let UID234_delta = {\n   *  age: 31,\n   *  traits: {eyes: 'blue', shoe_size: 10},\n   * };\n   *\n   * // second user, initial values\n   * let UID345_object = {\n   *  name: 'Marge',\n   *  age: 25,\n   *  traits: {hair: 'blonde', eyes: 'blue'},\n   * };\n   *\n   * // second user, delta values\n   * let UID345_delta = {\n   *  age: 26,\n   *  traits: {eyes: 'green', shoe_size: 6},\n   * };\n   *\n   * let multi_set_pairs   = [['UID234', JSON.stringify(UID234_object)], ['UID345', JSON.stringify(UID345_object)]]\n   * let multi_merge_pairs = [['UID234', JSON.stringify(UID234_delta)], ['UID345', JSON.stringify(UID345_delta)]]\n   *\n   * AsyncStorage.multiSet(multi_set_pairs, (err) => {\n   *   AsyncStorage.multiMerge(multi_merge_pairs, (err) => {\n   *     AsyncStorage.multiGet(['UID234','UID345'], (err, stores) => {\n   *       stores.map( (result, i, store) => {\n   *         let key = store[i][0];\n   *         let val = store[i][1];\n   *         console.log(key, val);\n   *       });\n   *     });\n   *   });\n   * });\n   *\n   * // Console log results:\n   * // => UID234 {\"name\":\"Chris\",\"age\":31,\"traits\":{\"shoe_size\":10,\"hair\":\"brown\",\"eyes\":\"blue\"}}\n   * // => UID345 {\"name\":\"Marge\",\"age\":26,\"traits\":{\"shoe_size\":6,\"hair\":\"blonde\",\"eyes\":\"green\"}}\n   */\n  multiMerge: function(\n    keyValuePairs: Array<Array<string>>,\n    callback?: ?(errors: ?Array<Error>) => void\n  ): Promise {\n    return new Promise((resolve, reject) => {\n      RCTAsyncStorage.multiMerge(keyValuePairs, function(errors) {\n        var error = convertErrors(errors);\n        callback && callback(error);\n        if (error) {\n          reject(error);\n        } else {\n          resolve(null);\n        }\n      });\n    });\n  },\n};\n\n// Not all native implementations support merge.\nif (!RCTAsyncStorage.multiMerge) {\n  delete AsyncStorage.mergeItem;\n  delete AsyncStorage.multiMerge;\n}\n\nfunction convertErrors(errs) {\n  if (!errs) {\n    return null;\n  }\n  return (Array.isArray(errs) ? errs : [errs]).map((e) => convertError(e));\n}\n\nfunction convertError(error) {\n  if (!error) {\n    return null;\n  }\n  var out = new Error(error.message);\n  out.key = error.key; // flow doesn't like this :(\n  return out;\n}\n\nmodule.exports = AsyncStorage;\n"]}]