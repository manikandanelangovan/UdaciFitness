["aae0a22f455cebe2a7282403efadeff629535e3b","483a2194760bf8b49854a4ca967a82fccd586841",["react-native","./AV","regenerator-runtime"],[3931,3967,4010],{"version":3,"sources":["/Users/mani/Documents/Udacity/Core/React_Native/UdaciFitness/node_modules/expo/src/av/Audio.js"],"names":["setIsEnabledAsync","setAudioModeAsync","RECORDING_OPTION_ANDROID_OUTPUT_FORMAT_DEFAULT","RECORDING_OPTION_ANDROID_OUTPUT_FORMAT_THREE_GPP","RECORDING_OPTION_ANDROID_OUTPUT_FORMAT_MPEG_4","RECORDING_OPTION_ANDROID_OUTPUT_FORMAT_AMR_NB","RECORDING_OPTION_ANDROID_OUTPUT_FORMAT_AMR_WB","RECORDING_OPTION_ANDROID_OUTPUT_FORMAT_AAC_ADIF","RECORDING_OPTION_ANDROID_OUTPUT_FORMAT_AAC_ADTS","RECORDING_OPTION_ANDROID_OUTPUT_FORMAT_RTP_AVP","RECORDING_OPTION_ANDROID_OUTPUT_FORMAT_MPEG2TS","RECORDING_OPTION_ANDROID_OUTPUT_FORMAT_WEBM","RECORDING_OPTION_ANDROID_AUDIO_ENCODER_DEFAULT","RECORDING_OPTION_ANDROID_AUDIO_ENCODER_AMR_NB","RECORDING_OPTION_ANDROID_AUDIO_ENCODER_AMR_WB","RECORDING_OPTION_ANDROID_AUDIO_ENCODER_AAC","RECORDING_OPTION_ANDROID_AUDIO_ENCODER_HE_AAC","RECORDING_OPTION_ANDROID_AUDIO_ENCODER_AAC_ELD","RECORDING_OPTION_ANDROID_AUDIO_ENCODER_VORBIS","RECORDING_OPTION_IOS_OUTPUT_FORMAT_LINEARPCM","RECORDING_OPTION_IOS_OUTPUT_FORMAT_AC3","RECORDING_OPTION_IOS_OUTPUT_FORMAT_60958AC3","RECORDING_OPTION_IOS_OUTPUT_FORMAT_APPLEIMA4","RECORDING_OPTION_IOS_OUTPUT_FORMAT_MPEG4AAC","RECORDING_OPTION_IOS_OUTPUT_FORMAT_MPEG4CELP","RECORDING_OPTION_IOS_OUTPUT_FORMAT_MPEG4HVXC","RECORDING_OPTION_IOS_OUTPUT_FORMAT_MPEG4TWINVQ","RECORDING_OPTION_IOS_OUTPUT_FORMAT_MACE3","RECORDING_OPTION_IOS_OUTPUT_FORMAT_MACE6","RECORDING_OPTION_IOS_OUTPUT_FORMAT_ULAW","RECORDING_OPTION_IOS_OUTPUT_FORMAT_ALAW","RECORDING_OPTION_IOS_OUTPUT_FORMAT_QDESIGN","RECORDING_OPTION_IOS_OUTPUT_FORMAT_QDESIGN2","RECORDING_OPTION_IOS_OUTPUT_FORMAT_QUALCOMM","RECORDING_OPTION_IOS_OUTPUT_FORMAT_MPEGLAYER1","RECORDING_OPTION_IOS_OUTPUT_FORMAT_MPEGLAYER2","RECORDING_OPTION_IOS_OUTPUT_FORMAT_MPEGLAYER3","RECORDING_OPTION_IOS_OUTPUT_FORMAT_APPLELOSSLESS","RECORDING_OPTION_IOS_OUTPUT_FORMAT_MPEG4AAC_HE","RECORDING_OPTION_IOS_OUTPUT_FORMAT_MPEG4AAC_LD","RECORDING_OPTION_IOS_OUTPUT_FORMAT_MPEG4AAC_ELD","RECORDING_OPTION_IOS_OUTPUT_FORMAT_MPEG4AAC_ELD_SBR","RECORDING_OPTION_IOS_OUTPUT_FORMAT_MPEG4AAC_ELD_V2","RECORDING_OPTION_IOS_OUTPUT_FORMAT_MPEG4AAC_HE_V2","RECORDING_OPTION_IOS_OUTPUT_FORMAT_MPEG4AAC_SPATIAL","RECORDING_OPTION_IOS_OUTPUT_FORMAT_AMR","RECORDING_OPTION_IOS_OUTPUT_FORMAT_AMR_WB","RECORDING_OPTION_IOS_OUTPUT_FORMAT_AUDIBLE","RECORDING_OPTION_IOS_OUTPUT_FORMAT_ILBC","RECORDING_OPTION_IOS_OUTPUT_FORMAT_DVIINTELIMA","RECORDING_OPTION_IOS_OUTPUT_FORMAT_MICROSOFTGSM","RECORDING_OPTION_IOS_OUTPUT_FORMAT_AES3","RECORDING_OPTION_IOS_OUTPUT_FORMAT_ENHANCEDAC3","RECORDING_OPTION_IOS_AUDIO_QUALITY_MIN","RECORDING_OPTION_IOS_AUDIO_QUALITY_LOW","RECORDING_OPTION_IOS_AUDIO_QUALITY_MEDIUM","RECORDING_OPTION_IOS_AUDIO_QUALITY_HIGH","RECORDING_OPTION_IOS_AUDIO_QUALITY_MAX","RECORDING_OPTION_IOS_BIT_RATE_STRATEGY_CONSTANT","RECORDING_OPTION_IOS_BIT_RATE_STRATEGY_LONG_TERM_AVERAGE","RECORDING_OPTION_IOS_BIT_RATE_STRATEGY_VARIABLE_CONSTRAINED","RECORDING_OPTION_IOS_BIT_RATE_STRATEGY_VARIABLE","RECORDING_OPTIONS_PRESET_HIGH_QUALITY","android","extension","outputFormat","audioEncoder","sampleRate","numberOfChannels","bitRate","ios","audioQuality","linearPCMBitDepth","linearPCMIsBigEndian","linearPCMIsFloat","RECORDING_OPTIONS_PRESET_LOW_QUALITY","INTERRUPTION_MODE_IOS_MIX_WITH_OTHERS","INTERRUPTION_MODE_IOS_DO_NOT_MIX","INTERRUPTION_MODE_IOS_DUCK_OTHERS","INTERRUPTION_MODE_ANDROID_DO_NOT_MIX","INTERRUPTION_MODE_ANDROID_DUCK_OTHERS","_enabled","_recorderExists","_DISABLED_ERROR","Error","_isValueValid","value","validValues","filter","validValue","length","_findMissingKeys","object","requiredKeys","requiredKey","ExponentAV","setAudioIsEnabled","mode","missingKeys","JSON","stringify","interruptionModeIOS","interruptionModeAndroid","allowsRecordingIOS","playsInSilentModeIOS","shouldDuckAndroid","setAudioMode","Sound","_internalStatusUpdateCallback","status","_callOnPlaybackStatusUpdateForNewStatus","_setInternalStatusUpdateCallback","_errorCallback","error","_loaded","_key","getStatusAsync","_performOperationAndHandleStatusAsync","getStatusForSound","setCallback","callback","console","warn","setOnPlaybackStatusUpdate","_loading","_onPlaybackStatusUpdate","operation","setStatusUpdateCallbackForSound","onPlaybackStatusUpdate","source","initialStatus","downloadFirst","loading","uri","fullInitialStatus","Promise","resolve","reject","loadSuccess","key","setErrorCallbackForSound","loadError","loadForSound","bind","unloadForSound","setStatusForSound","create","sound","loadAsync","prototype","Recording","_cleanupForUnloadedRecorder","finalStatus","_canRecord","_isDoneRecording","_finalDurationMillis","durationMillis","setUnloadedCallbackForAndroidRecording","_disablePolling","_pollingLoop","_onRecordingStatusUpdate","_progressUpdateTimeoutVariable","setTimeout","_progressUpdateIntervalMillis","getAudioRecordingStatus","canRecord","isDoneRecording","_callOnRecordingStatusUpdateForNewStatus","_uri","_options","clearTimeout","onRecordingStatusUpdate","_enablePollingIfNecessaryAndPossible","setOnRecordingStatusUpdate","progressUpdateIntervalMillis","options","extensionRegex","test","toString","prepareAudioRecorder","startAudioRecording","pauseAudioRecording","stopAudioRecording","unloadAudioRecorder"],"mappings":";;;;;;;;;QAwMsBA,iB,GAAAA,iB;QASAC,iB,GAAAA,iB;;AA/MtB;;AAEA;;;;AAoCO,IAAMC,0GAAiD,CAAvD;AACA,IAAMC,8GAAmD,CAAzD;AACA,IAAMC,wGAAgD,CAAtD;AACA,IAAMC,wGAAgD,CAAtD;AACA,IAAMC,wGAAgD,CAAtD;AACA,IAAMC,4GAAkD,CAAxD;AACA,IAAMC,4GAAkD,CAAxD;AACA,IAAMC,0GAAiD,CAAvD;AACA,IAAMC,0GAAiD,CAAvD;AACA,IAAMC,oGAA8C,CAApD;;AAEA,IAAMC,0GAAiD,CAAvD;AACA,IAAMC,wGAAgD,CAAtD;AACA,IAAMC,wGAAgD,CAAtD;AACA,IAAMC,kGAA6C,CAAnD;AACA,IAAMC,wGAAgD,CAAtD;AACA,IAAMC,0GAAiD,CAAvD;AACA,IAAMC,wGAAgD,CAAtD;;AAEA,IAAMC,sGAA+C,MAArD;AACA,IAAMC,0FAAyC,MAA/C;AACA,IAAMC,oGAA8C,MAApD;AACA,IAAMC,sGAA+C,MAArD;AACA,IAAMC,oGAA8C,MAApD;AACA,IAAMC,sGAA+C,MAArD;AACA,IAAMC,sGAA+C,MAArD;AACA,IAAMC,0GAAiD,MAAvD;AACA,IAAMC,8FAA2C,MAAjD;AACA,IAAMC,8FAA2C,MAAjD;AACA,IAAMC,4FAA0C,MAAhD;AACA,IAAMC,4FAA0C,MAAhD;AACA,IAAMC,kGAA6C,MAAnD;AACA,IAAMC,oGAA8C,MAApD;AACA,IAAMC,oGAA8C,MAApD;AACA,IAAMC,wGAAgD,MAAtD;AACA,IAAMC,wGAAgD,MAAtD;AACA,IAAMC,wGAAgD,MAAtD;AACA,IAAMC,8GAAmD,MAAzD;AACA,IAAMC,0GAAiD,MAAvD;AACA,IAAMC,0GAAiD,MAAvD;AACA,IAAMC,4GAAkD,MAAxD;AACA,IAAMC,oHAAsD,MAA5D;AACA,IAAMC,kHAAqD,MAA3D;AACA,IAAMC,gHAAoD,MAA1D;AACA,IAAMC,oHAAsD,MAA5D;AACA,IAAMC,0FAAyC,MAA/C;AACA,IAAMC,gGAA4C,MAAlD;AACA,IAAMC,kGAA6C,MAAnD;AACA,IAAMC,4FAA0C,MAAhD;AACA,IAAMC,0GAAiD,UAAvD;AACA,IAAMC,4GAAkD,UAAxD;AACA,IAAMC,4FAA0C,MAAhD;AACA,IAAMC,0GAAiD,MAAvD;;AAEA,IAAMC,0FAAyC,CAA/C;AACA,IAAMC,0FAAyC,IAA/C;AACA,IAAMC,gGAA4C,IAAlD;AACA,IAAMC,4FAA0C,IAAhD;AACA,IAAMC,0FAAyC,IAA/C;;AAEA,IAAMC,4GAAkD,CAAxD;AACA,IAAMC,8HAA2D,CAAjE;AACA,IAAMC,oIAA8D,CAApE;AACA,IAAMC,4GAAkD,CAAxD;;AAIA,IAAMC,wFAA0D;AACrEC,WAAS;AACPC,eAAW,MADJ;AAEPC,kBAAc7D,6CAFP;AAGP8D,kBAAcnD,0CAHP;AAIPoD,gBAAY,KAJL;AAKPC,sBAAkB,CALX;AAMPC,aAAS;AANF,GAD4D;AASrEC,OAAK;AACHN,eAAW,MADR;AAEHO,kBAAcd,sCAFX;AAGHU,gBAAY,KAHT;AAIHC,sBAAkB,CAJf;AAKHC,aAAS,MALN;AAMHG,uBAAmB,EANhB;AAOHC,0BAAsB,KAPnB;AAQHC,sBAAkB;AARf;AATgE,CAAhE;;AAqBA,IAAMC,sFAAyD;AACpEZ,WAAS;AACPC,eAAW,MADJ;AAEPC,kBAAc9D,gDAFP;AAGP+D,kBAAcrD,6CAHP;AAIPsD,gBAAY,KAJL;AAKPC,sBAAkB,CALX;AAMPC,aAAS;AANF,GAD2D;AASpEC,OAAK;AACHN,eAAW,MADR;AAEHO,kBAAclB,sCAFX;AAGHc,gBAAY,KAHT;AAIHC,sBAAkB,CAJf;AAKHC,aAAS,MALN;AAMHG,uBAAmB,EANhB;AAOHC,0BAAsB,KAPnB;AAQHC,sBAAkB;AARf;AAT+D,CAA/D;;AA8CA,IAAME,wFAAwC,CAA9C;AACA,IAAMC,8EAAmC,CAAzC;AACA,IAAMC,gFAAoC,CAA1C;;AAEA,IAAMC,sFAAuC,CAA7C;AACA,IAAMC,wFAAwC,CAA9C;;AAEP,IAAIC,WAAoB,IAAxB;AACA,IAAIC,kBAA2B,KAA/B;AACA,IAAMC,kBAAyB,IAAIC,KAAJ,CAC7B,yDAD6B,CAA/B;;AAKA,IAAMC,gBAAgB,SAAhBA,aAAgB,CAACC,KAAD,EAAaC,WAAb,EAAkD;AACtE,SAAOA,YAAYC,MAAZ,CAAmB;AAAA,WAAcC,eAAeH,KAA7B;AAAA,GAAnB,EAAuDI,MAAvD,GAAgE,CAAvE;AACD,CAFD;;AAKA,IAAMC,mBAAmB,SAAnBA,gBAAmB,CACvBC,MADuB,EAEvBC,YAFuB,EAGR;AACf,SAAOA,aAAaL,MAAb,CAAoB;AAAA,WAAe,EAAEM,eAAeF,MAAjB,CAAf;AAAA,GAApB,CAAP;AACD,CALD;;AAOO,SAAe5F,iBAAf,CAAiCsF,KAAjC;AAAA;AAAA;AAAA;AAAA;AACLL,qBAAWK,KAAX;AADK;AAAA,0CAEC,2BAAcS,UAAd,CAAyBC,iBAAzB,CAA2CV,KAA3C,CAFD;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AASA,SAAerF,iBAAf,CAAiCgG,IAAjC;AAAA;AAAA;AAAA;AAAA;AAAA;AACCC,qBADD,GACeP,iBAAiBM,IAAjB,EAAuB,CACzC,oBADyC,EAEzC,qBAFyC,EAGzC,sBAHyC,EAIzC,yBAJyC,EAKzC,mBALyC,CAAvB,CADf;;AAAA,gBAQDC,YAAYR,MAAZ,GAAqB,CARpB;AAAA;AAAA;AAAA;;AAAA,gBASG,IAAIN,KAAJ,gEACyDe,KAAKC,SAAL,CAC3DF,WAD2D,CADzD,CATH;;AAAA;AAAA,cAgBFb,cAAcY,KAAKI,mBAAnB,EAAwC,CACvCzB,qCADuC,EAEvCC,gCAFuC,EAGvCC,iCAHuC,CAAxC,CAhBE;AAAA;AAAA;AAAA;;AAAA,gBAsBG,IAAIM,KAAJ,sDAtBH;;AAAA;AAAA,cAyBFC,cAAcY,KAAKK,uBAAnB,EAA4C,CAC3CvB,oCAD2C,EAE3CC,qCAF2C,CAA5C,CAzBE;AAAA;AAAA;AAAA;;AAAA,gBA8BG,IAAII,KAAJ,0DA9BH;;AAAA;AAAA,gBAiCH,OAAOa,KAAKM,kBAAZ,KAAmC,SAAnC,IACA,OAAON,KAAKO,oBAAZ,KAAqC,SADrC,IAEA,OAAOP,KAAKQ,iBAAZ,KAAkC,SAnC/B;AAAA;AAAA;AAAA;;AAAA,gBAqCG,IAAIrB,KAAJ,CACJ,yFADI,CArCH;;AAAA;AAAA;AAAA,0CAyCC,2BAAcW,UAAd,CAAyBW,YAAzB,CAAsCT,IAAtC,CAzCD;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;IA4CMU,K,WAAAA,K;AAMX,mBAAc;AAAA;;AAAA;;AAAA,SA8CdC,6BA9Cc,GA8CkB,UAACC,MAAD,EAA4B;AAC1D,YAAKC,uCAAL,CAA6CD,MAA7C;AACA,YAAKE,gCAAL;AACD,KAjDa;;AAAA,SA6DdC,cA7Dc,GA6DG,UAACC,KAAD,EAAmB;AAClC,YAAKC,OAAL,GAAe,KAAf;AACA,YAAKC,IAAL,GAAY,CAAC,CAAb;AACA,YAAKL,uCAAL,CAA6C,4BAAmBG,KAAnB,CAA7C;AACD,KAjEa;;AAAA,SAwEdG,cAxEc,GAwEG;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,mBACX,MAAKF,OADM;AAAA;AAAA;AAAA;;AAAA,gDAEN,MAAKG,qCAAL,CAA2C;AAAA,uBAChD,2BAActB,UAAd,CAAyBuB,iBAAzB,CAA2C,MAAKH,IAAhD,CADgD;AAAA,eAA3C,CAFM;;AAAA;AAMTN,oBANS,GAMgB,6BANhB;;AAOf,oBAAKC,uCAAL,CAA6CD,MAA7C;AAPe,gDAQRA,MARQ;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,KAxEH;;AAAA,SA2FdU,WA3Fc,GA2FA,UAACC,QAAD,EAAiD;AAC7DC,cAAQC,IAAR;AAGA,YAAKC,yBAAL,CAA+BH,QAA/B;AACD,KAhGa;;AACZ,SAAKN,OAAL,GAAe,KAAf;AACA,SAAKU,QAAL,GAAgB,KAAhB;AACA,SAAKT,IAAL,GAAY,CAAC,CAAb;AACA,SAAKU,uBAAL,GAA+B,IAA/B;AACD;;;;4DAoBuChB,M,EAAwB;AAC9D,UAAI,KAAKgB,uBAAL,IAAgC,IAApC,EAA0C;AACxC,aAAKA,uBAAL,CAA6BhB,MAA7B;AACD;AACF;;;0DAGCiB,S;;;;;;;kBAEK7C,Q;;;;;oBACGE,e;;;mBAEJ,KAAK+B,O;;;;;;8CACcY,W;;;AAAfjB,qB;;AACN,mBAAKC,uCAAL,CAA6CD,OAA7C;gDACOA,O;;;oBAED,IAAIzB,KAAJ,CAAU,wDAAV,C;;;;;;;;;;;uDAUyB;AACjC,UAAI,KAAK8B,OAAT,EAAkB;AAChB,mCAAcnB,UAAd,CAAyBgC,+BAAzB,CACE,KAAKZ,IADP,EAEE,KAAKP,6BAFP;AAID;AACF;;;8CAyBCoB,sB,EACA;AACA,WAAKH,uBAAL,GAA+BG,sBAA/B;AACA,WAAKZ,cAAL;AACD;;;8BAaCa,M;UACAC,a,uEAAqC,E;UACrCC,a,uEAAyB,I;;;;;;;;kBAEpBlD,Q;;;;;oBACGE,e;;;mBAEJ,KAAKiD,O;;;;;oBACD,IAAIhD,KAAJ,CAAU,+BAAV,C;;;kBAEH,KAAK8B,O;;;;;AACR,mBAAKU,QAAL,GAAgB,IAAhB;;;8CAKU,iDACRK,MADQ,EAERC,aAFQ,EAGRC,aAHQ,C;;;;AAFRE,iB,QAAAA,G;AACAC,+B,QAAAA,iB;gDAQK,IAAIC,OAAJ,CACL,UAASC,OAAT,EAAkBC,MAAlB,EAA0B;AAAA;;AACxB,oBAAMC,cAAc,SAAdA,WAAc,CAACC,GAAD,EAAc9B,MAAd,EAAyC;AAC3D,yBAAKM,IAAL,GAAYwB,GAAZ;AACA,yBAAKzB,OAAL,GAAe,IAAf;AACA,yBAAKU,QAAL,GAAgB,KAAhB;AACA,6CAAc7B,UAAd,CAAyB6C,wBAAzB,CACE,OAAKzB,IADP,EAEE,OAAKH,cAFP;AAIA,yBAAKD,gCAAL;AACA,yBAAKD,uCAAL,CAA6CD,MAA7C;AACA2B,0BAAQ3B,MAAR;AACD,iBAXD;AAYA,oBAAMgC,YAAY,SAAZA,SAAY,CAAC5B,KAAD,EAAmB;AACnC,yBAAKW,QAAL,GAAgB,KAAhB;AACAa,yBAAO,IAAIrD,KAAJ,CAAU6B,KAAV,CAAP;AACD,iBAHD;AAIA,2CAAclB,UAAd,CAAyB+C,YAAzB,CACET,GADF,EAEEC,iBAFF,EAGEI,WAHF,EAIEG,SAJF;AAMD,eAvBD,CAuBEE,IAvBF,CAuBO,IAvBP,CADK,C;;;oBA2BD,IAAI3D,KAAJ,CAAU,8BAAV,C;;;;;;;;;;;;;;;;;;mBAKJ,KAAK8B,O;;;;;AACP,mBAAKA,OAAL,GAAe,KAAf;AACMyB,iB,GAAM,KAAKxB,I;;AACjB,mBAAKA,IAAL,GAAY,CAAC,CAAb;;8CACqB,2BAAcpB,UAAd,CAAyBiD,cAAzB,CAAwCL,GAAxC,C;;;AAAf9B,sB;;AACN,mBAAKC,uCAAL,CAA6CD,QAA7C;gDACOA,Q;;;gDAEA,KAAKO,cAAL,E;;;;;;;;;;;mCAMUP,M;;;;;;;AACnB,8DAAuCA,MAAvC;gDACO,KAAKQ,qCAAL,CAA2C;AAAA,uBAChD,2BAActB,UAAd,CAAyBkD,iBAAzB,CAA2C,OAAK9B,IAAhD,EAAsDN,MAAtD,CADgD;AAAA,eAA3C,C;;;;;;;;;;;YArKFqC,M,GAAS,kBACdjB,MADc;AAAA,MAEdC,aAFc,uEAEuB,EAFvB;AAAA,MAGdF,sBAHc,uEAG8C,IAH9C;AAAA,MAIdG,aAJc,uEAIW,IAJX;AAAA;AAAA;AAAA;AAAA;AAAA;AAMRgB,eANQ,GAMO,IAAIxC,KAAJ,EANP;;AAOdwC,gBAAMxB,yBAAN,CAAgCK,sBAAhC;AAPc;AAAA,0CAQuBmB,MAAMC,SAAN,CACnCnB,MADmC,EAEnCC,aAFmC,EAGnCC,aAHmC,CARvB;;AAAA;AAQRtB,gBARQ;AAAA,4CAaP,EAAEsC,YAAF,EAAStC,cAAT,EAbO;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,C;;;AA4LlB,qBAAcF,MAAM0C,SAApB;;IAEaC,S,WAAAA,S;AAUX,uBAAc;AAAA;;AAAA;;AAAA,SAYdC,2BAZc,GAYgB,kBAAOC,WAAP;AAAA;AAAA;AAAA;AAAA;AAC5B,qBAAKC,UAAL,GAAkB,KAAlB;AACA,qBAAKC,gBAAL,GAAwB,IAAxB;;AAEA,qBAAKC,oBAAL,GAA4BH,YAAYI,cAAxC;AACA1E,gCAAkB,KAAlB;AACA,kBAAI,2BAAca,UAAd,CAAyB8D,sCAA7B,EAAqE;AACnE,2CAAc9D,UAAd,CAAyB8D,sCAAzB,CAAgE,IAAhE;AACD;AACD,qBAAKC,eAAL;AAT4B;AAAA,8CAUf,OAAK1C,cAAL,EAVe;;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,KAZhB;;AAAA,SAyBd2C,YAzBc,GAyBC;AAAA;AAAA;AAAA;AAAA;AAAA,oBACT9E,YAAY,OAAKwE,UAAjB,IAA+B,OAAKO,wBAAL,IAAiC,IADvD;AAAA;AAAA;AAAA;;AAEX,qBAAKC,8BAAL,GAAsCC,WACpC,OAAKH,YAD+B,EAEpC,OAAKI,6BAF+B,CAAtC;AAFW;AAAA;AAAA,8CAOH,OAAK/C,cAAL,EAPG;;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AAST,qBAAK0C,eAAL;;AATS;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,KAzBD;;AAAA,SAgFd1C,cAhFc,GAgFG;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,mBAEX,OAAKqC,UAFM;AAAA;AAAA;AAAA;;AAAA,iDAGN,OAAKpC,qCAAL,CAA2C;AAAA,uBAChD,2BAActB,UAAd,CAAyBqE,uBAAzB,EADgD;AAAA,eAA3C,CAHM;;AAAA;AAOTvD,oBAPS,GAOiB,OAAK6C,gBAAL,GAC5B;AACEW,2BAAW,KADb;AAEEC,iCAAiB,IAFnB;AAGEV,gCAAgB,OAAKD;AAHvB,eAD4B,GAM5B;AACEU,2BAAW,KADb;AAEEC,iCAAiB;AAFnB,eAbW;;AAiBf,qBAAKC,wCAAL,CAA8C1D,MAA9C;AAjBe,iDAkBRA,MAlBQ;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,KAhFH;;AACZ,SAAK4C,UAAL,GAAkB,KAAlB;AACA,SAAKC,gBAAL,GAAwB,KAAxB;AACA,SAAKC,oBAAL,GAA4B,CAA5B;AACA,SAAKa,IAAL,GAAY,IAAZ;AACA,SAAKP,8BAAL,GAAsC,IAAtC;AACA,SAAKE,6BAAL;AACA,SAAKM,QAAL,GAAgB,IAAhB;AACD;;;;sCA+BiB;AAChB,UAAI,KAAKR,8BAAL,IAAuC,IAA3C,EAAiD;AAC/CS,qBAAa,KAAKT,8BAAlB;AACA,aAAKA,8BAAL,GAAsC,IAAtC;AACD;AACF;;;2DAEsC;AACrC,UAAIhF,YAAY,KAAKwE,UAAjB,IAA+B,KAAKO,wBAAL,IAAiC,IAApE,EAA0E;AACxE,aAAKF,eAAL;AACA,aAAKC,YAAL;AACD;AACF;;;6DAEwClD,M,EAAyB;AAChE,UAAI,KAAKmD,wBAAL,IAAiC,IAArC,EAA2C;AACzC,aAAKA,wBAAL,CAA8BnD,MAA9B;AACD;AACF;;;0DAGCiB,S;;;;;;;kBAEK7C,Q;;;;;oBACGE,e;;;mBAEJ,KAAKsE,U;;;;;;8CACc3B,W;;;AAAfjB,sB;;AACN,mBAAK0D,wCAAL,CAA8C1D,QAA9C;iDACOA,Q;;;oBAED,IAAIzB,KAAJ,CACJ,yEADI,C;;;;;;;;;;;+CAgCRuF,uB,EACA;AACA,WAAKX,wBAAL,GAAgCW,uBAAhC;AACA,UAAIA,2BAA2B,IAA/B,EAAqC;AACnC,aAAKb,eAAL;AACD,OAFD,MAEO;AACL,aAAKc,oCAAL;AACD;AACD,WAAKxD,cAAL;AACD;;;gCAGWI,Q,EAA8C;AAExDC,cAAQC,IAAR;AAGA,WAAKmD,0BAAL,CAAgCrD,QAAhC;AACD;;;8CAEyBsD,4B,EAAsC;AAC9D,WAAKX,6BAAL,GAAqCW,4BAArC;AACA,WAAK1D,cAAL;AACD;;;;UAKC2D,O,uEAA4BpG,oC;;;;;;;;kBAEvBM,Q;;;;;oBACGE,e;;;mBAGJD,e;;;;;oBACI,IAAIE,KAAJ,CACJ,4DADI,C;;;mBAKJ,KAAKsE,gB;;;;;oBACD,IAAItE,KAAJ,CACJ,mEADI,C;;;oBAKJ,CAAC2F,OAAD,IAAY,CAACA,QAAQhH,OAArB,IAAgC,CAACgH,QAAQzG,G;;;;;oBACrC,IAAIc,KAAJ,CACJ,uFADI,C;;;AAKF4F,4B,GAAiB,S;;oBAErB,CAACD,QAAQhH,OAAR,CAAgBC,SAAjB,IACA,CAAC+G,QAAQzG,GAAR,CAAYN,SADb,IAEA,CAACgH,eAAeC,IAAf,CAAoBF,QAAQhH,OAAR,CAAgBC,SAApC,CAFD,IAGA,CAACgH,eAAeC,IAAf,CAAoBF,QAAQzG,GAAR,CAAYN,SAAhC,C;;;;;oBAEK,IAAIoB,KAAJ,sCAC+B4F,eAAeE,QAAf,EAD/B,O;;;kBAKH,KAAKzB,U;;;;;AACR,kBAAI,2BAAc1D,UAAd,CAAyB8D,sCAA7B,EAAqE;AACnE,2CAAc9D,UAAd,CAAyB8D,sCAAzB,CACE,KAAKN,2BADP;AAGD;;;8CAQS,2BAAcxD,UAAd,CAAyBoF,oBAAzB,CAA8CJ,OAA9C,C;;;;AALR1C,iB,SAAAA,G;AACAxB,sB,SAAAA,M;;AAKF3B,gCAAkB,IAAlB;AACA,mBAAKsF,IAAL,GAAYnC,GAAZ;AACA,mBAAKoC,QAAL,GAAgBM,OAAhB;AACA,mBAAKtB,UAAL,GAAkB,IAAlB;AACA,mBAAKc,wCAAL,CAA8C1D,QAA9C;AACA,mBAAK+D,oCAAL;iDACO/D,Q;;;oBAED,IAAIzB,KAAJ,CAAU,sDAAV,C;;;;;;;;;;;;;;;;iDAKD,KAAKiC,qCAAL,CAA2C;AAAA,uBAChD,2BAActB,UAAd,CAAyBqF,mBAAzB,EADgD;AAAA,eAA3C,C;;;;;;;;;;;;;;;;iDAMA,KAAK/D,qCAAL,CAA2C;AAAA,uBAChD,2BAActB,UAAd,CAAyBsF,mBAAzB,EADgD;AAAA,eAA3C,C;;;;;;;;;;;;;;;;;kBAMF,KAAK5B,U;;;;;mBACJ,KAAKC,gB;;;;;oBACD,IAAItE,KAAJ,CACJ,2DADI,C;;;oBAIA,IAAIA,KAAJ,CACJ,uDADI,C;;;;8CAOwB,2BAAcW,UAAd,CAAyBuF,kBAAzB,E;;;AAA5B9B,yB;;8CACA,2BAAczD,UAAd,CAAyBwF,mBAAzB,E;;;iDACC,KAAKhC,2BAAL,CAAiCC,WAAjC,C;;;;;;;;;;;6BAKS;AAChB,aAAO,KAAKgB,IAAZ;AACD;;;;UAGCtC,a,uEAAqC,E;UACrCF,sB,uEAA4D,I;;;;;oBAExD,KAAKwC,IAAL,IAAa,IAAb,IAAqB,CAAC,KAAKd,gB;;;;;oBACvB,IAAItE,KAAJ,CACJ,0DADI,C;;;iDAIDuB,MAAMuC,MAAN,CAEL,EAAEb,KAAK,KAAKmC,IAAZ,EAFK,EAGLtC,aAHK,EAILF,sBAJK,EAKL,KALK,C","sourcesContent":["// @flow\n\nimport { NativeModules } from 'react-native';\n\nimport {\n  _DEFAULT_PROGRESS_UPDATE_INTERVAL_MILLIS,\n  _COMMON_AV_PLAYBACK_METHODS,\n  _getURIAndFullInitialStatusForLoadAsync,\n  _throwErrorIfValuesOutOfBoundsInStatus,\n  _getUnloadedStatus,\n  type PlaybackSource,\n  type PlaybackStatus,\n  type PlaybackStatusToSet,\n} from './AV';\n\nexport type RecordingOptions = {\n  android: {\n    extension: string,\n    outputFormat: number,\n    audioEncoder: number,\n    sampleRate?: number,\n    numberOfChannels?: number,\n    bitRate?: number,\n    maxFileSize?: number,\n  },\n  ios: {\n    extension: string,\n    outputFormat?: string | number,\n    audioQuality: number,\n    sampleRate: number,\n    numberOfChannels: number,\n    bitRate: number,\n    bitRateStrategy?: number,\n    bitDepthHint?: number,\n    linearPCMBitDepth?: number,\n    linearPCMIsBigEndian?: boolean,\n    linearPCMIsFloat?: boolean,\n  },\n};\n\nexport const RECORDING_OPTION_ANDROID_OUTPUT_FORMAT_DEFAULT = 0;\nexport const RECORDING_OPTION_ANDROID_OUTPUT_FORMAT_THREE_GPP = 1;\nexport const RECORDING_OPTION_ANDROID_OUTPUT_FORMAT_MPEG_4 = 2;\nexport const RECORDING_OPTION_ANDROID_OUTPUT_FORMAT_AMR_NB = 3;\nexport const RECORDING_OPTION_ANDROID_OUTPUT_FORMAT_AMR_WB = 4;\nexport const RECORDING_OPTION_ANDROID_OUTPUT_FORMAT_AAC_ADIF = 5;\nexport const RECORDING_OPTION_ANDROID_OUTPUT_FORMAT_AAC_ADTS = 6;\nexport const RECORDING_OPTION_ANDROID_OUTPUT_FORMAT_RTP_AVP = 7;\nexport const RECORDING_OPTION_ANDROID_OUTPUT_FORMAT_MPEG2TS = 8;\nexport const RECORDING_OPTION_ANDROID_OUTPUT_FORMAT_WEBM = 9;\n\nexport const RECORDING_OPTION_ANDROID_AUDIO_ENCODER_DEFAULT = 0;\nexport const RECORDING_OPTION_ANDROID_AUDIO_ENCODER_AMR_NB = 1;\nexport const RECORDING_OPTION_ANDROID_AUDIO_ENCODER_AMR_WB = 2;\nexport const RECORDING_OPTION_ANDROID_AUDIO_ENCODER_AAC = 3;\nexport const RECORDING_OPTION_ANDROID_AUDIO_ENCODER_HE_AAC = 4;\nexport const RECORDING_OPTION_ANDROID_AUDIO_ENCODER_AAC_ELD = 5;\nexport const RECORDING_OPTION_ANDROID_AUDIO_ENCODER_VORBIS = 6;\n\nexport const RECORDING_OPTION_IOS_OUTPUT_FORMAT_LINEARPCM = 'lpcm';\nexport const RECORDING_OPTION_IOS_OUTPUT_FORMAT_AC3 = 'ac-3';\nexport const RECORDING_OPTION_IOS_OUTPUT_FORMAT_60958AC3 = 'cac3';\nexport const RECORDING_OPTION_IOS_OUTPUT_FORMAT_APPLEIMA4 = 'ima4';\nexport const RECORDING_OPTION_IOS_OUTPUT_FORMAT_MPEG4AAC = 'aac ';\nexport const RECORDING_OPTION_IOS_OUTPUT_FORMAT_MPEG4CELP = 'celp';\nexport const RECORDING_OPTION_IOS_OUTPUT_FORMAT_MPEG4HVXC = 'hvxc';\nexport const RECORDING_OPTION_IOS_OUTPUT_FORMAT_MPEG4TWINVQ = 'twvq';\nexport const RECORDING_OPTION_IOS_OUTPUT_FORMAT_MACE3 = 'MAC3';\nexport const RECORDING_OPTION_IOS_OUTPUT_FORMAT_MACE6 = 'MAC6';\nexport const RECORDING_OPTION_IOS_OUTPUT_FORMAT_ULAW = 'ulaw';\nexport const RECORDING_OPTION_IOS_OUTPUT_FORMAT_ALAW = 'alaw';\nexport const RECORDING_OPTION_IOS_OUTPUT_FORMAT_QDESIGN = 'QDMC';\nexport const RECORDING_OPTION_IOS_OUTPUT_FORMAT_QDESIGN2 = 'QDM2';\nexport const RECORDING_OPTION_IOS_OUTPUT_FORMAT_QUALCOMM = 'Qclp';\nexport const RECORDING_OPTION_IOS_OUTPUT_FORMAT_MPEGLAYER1 = '.mp1';\nexport const RECORDING_OPTION_IOS_OUTPUT_FORMAT_MPEGLAYER2 = '.mp2';\nexport const RECORDING_OPTION_IOS_OUTPUT_FORMAT_MPEGLAYER3 = '.mp3';\nexport const RECORDING_OPTION_IOS_OUTPUT_FORMAT_APPLELOSSLESS = 'alac';\nexport const RECORDING_OPTION_IOS_OUTPUT_FORMAT_MPEG4AAC_HE = 'aach';\nexport const RECORDING_OPTION_IOS_OUTPUT_FORMAT_MPEG4AAC_LD = 'aacl';\nexport const RECORDING_OPTION_IOS_OUTPUT_FORMAT_MPEG4AAC_ELD = 'aace';\nexport const RECORDING_OPTION_IOS_OUTPUT_FORMAT_MPEG4AAC_ELD_SBR = 'aacf';\nexport const RECORDING_OPTION_IOS_OUTPUT_FORMAT_MPEG4AAC_ELD_V2 = 'aacg';\nexport const RECORDING_OPTION_IOS_OUTPUT_FORMAT_MPEG4AAC_HE_V2 = 'aacp';\nexport const RECORDING_OPTION_IOS_OUTPUT_FORMAT_MPEG4AAC_SPATIAL = 'aacs';\nexport const RECORDING_OPTION_IOS_OUTPUT_FORMAT_AMR = 'samr';\nexport const RECORDING_OPTION_IOS_OUTPUT_FORMAT_AMR_WB = 'sawb';\nexport const RECORDING_OPTION_IOS_OUTPUT_FORMAT_AUDIBLE = 'AUDB';\nexport const RECORDING_OPTION_IOS_OUTPUT_FORMAT_ILBC = 'ilbc';\nexport const RECORDING_OPTION_IOS_OUTPUT_FORMAT_DVIINTELIMA = 0x6d730011;\nexport const RECORDING_OPTION_IOS_OUTPUT_FORMAT_MICROSOFTGSM = 0x6d730031;\nexport const RECORDING_OPTION_IOS_OUTPUT_FORMAT_AES3 = 'aes3';\nexport const RECORDING_OPTION_IOS_OUTPUT_FORMAT_ENHANCEDAC3 = 'ec-3';\n\nexport const RECORDING_OPTION_IOS_AUDIO_QUALITY_MIN = 0;\nexport const RECORDING_OPTION_IOS_AUDIO_QUALITY_LOW = 0x20;\nexport const RECORDING_OPTION_IOS_AUDIO_QUALITY_MEDIUM = 0x40;\nexport const RECORDING_OPTION_IOS_AUDIO_QUALITY_HIGH = 0x60;\nexport const RECORDING_OPTION_IOS_AUDIO_QUALITY_MAX = 0x7f;\n\nexport const RECORDING_OPTION_IOS_BIT_RATE_STRATEGY_CONSTANT = 0;\nexport const RECORDING_OPTION_IOS_BIT_RATE_STRATEGY_LONG_TERM_AVERAGE = 1;\nexport const RECORDING_OPTION_IOS_BIT_RATE_STRATEGY_VARIABLE_CONSTRAINED = 2;\nexport const RECORDING_OPTION_IOS_BIT_RATE_STRATEGY_VARIABLE = 3;\n\n// TODO : maybe make presets for music and speech, or lossy / lossless.\n\nexport const RECORDING_OPTIONS_PRESET_HIGH_QUALITY: RecordingOptions = {\n  android: {\n    extension: '.m4a',\n    outputFormat: RECORDING_OPTION_ANDROID_OUTPUT_FORMAT_MPEG_4,\n    audioEncoder: RECORDING_OPTION_ANDROID_AUDIO_ENCODER_AAC,\n    sampleRate: 44100,\n    numberOfChannels: 2,\n    bitRate: 128000,\n  },\n  ios: {\n    extension: '.caf',\n    audioQuality: RECORDING_OPTION_IOS_AUDIO_QUALITY_MAX,\n    sampleRate: 44100,\n    numberOfChannels: 2,\n    bitRate: 128000,\n    linearPCMBitDepth: 16,\n    linearPCMIsBigEndian: false,\n    linearPCMIsFloat: false,\n  },\n};\n\nexport const RECORDING_OPTIONS_PRESET_LOW_QUALITY: RecordingOptions = {\n  android: {\n    extension: '.3gp',\n    outputFormat: RECORDING_OPTION_ANDROID_OUTPUT_FORMAT_THREE_GPP,\n    audioEncoder: RECORDING_OPTION_ANDROID_AUDIO_ENCODER_AMR_NB,\n    sampleRate: 44100,\n    numberOfChannels: 2,\n    bitRate: 128000,\n  },\n  ios: {\n    extension: '.caf',\n    audioQuality: RECORDING_OPTION_IOS_AUDIO_QUALITY_MIN,\n    sampleRate: 44100,\n    numberOfChannels: 2,\n    bitRate: 128000,\n    linearPCMBitDepth: 16,\n    linearPCMIsBigEndian: false,\n    linearPCMIsFloat: false,\n  },\n};\n\n// TODO For consistency with PlaybackStatus, should we include progressUpdateIntervalMillis here as well?\nexport type RecordingStatus =\n  | {\n      canRecord: false,\n      isDoneRecording: false,\n    }\n  | {\n      canRecord: true,\n      isRecording: boolean,\n      durationMillis: number,\n    }\n  | {\n      canRecord: false,\n      isDoneRecording: true,\n      durationMillis: number,\n    };\n\nexport type AudioMode = {\n  allowsRecordingIOS: boolean,\n  interruptionModeIOS: number,\n  playsInSilentModeIOS: boolean,\n  interruptionModeAndroid: boolean,\n  shouldDuckAndroid: boolean,\n};\n\nexport const INTERRUPTION_MODE_IOS_MIX_WITH_OTHERS = 0;\nexport const INTERRUPTION_MODE_IOS_DO_NOT_MIX = 1;\nexport const INTERRUPTION_MODE_IOS_DUCK_OTHERS = 2;\n\nexport const INTERRUPTION_MODE_ANDROID_DO_NOT_MIX = 1;\nexport const INTERRUPTION_MODE_ANDROID_DUCK_OTHERS = 2;\n\nlet _enabled: boolean = true;\nlet _recorderExists: boolean = false;\nconst _DISABLED_ERROR: Error = new Error(\n  'Cannot complete operation because audio is not enabled.'\n);\n\n// Returns true if value is in validValues, and false if not.\nconst _isValueValid = (value: any, validValues: Array<any>): boolean => {\n  return validValues.filter(validValue => validValue === value).length > 0;\n};\n\n// Returns array of missing keys in object. Returns an empty array if no missing keys are found.\nconst _findMissingKeys = (\n  object: Object,\n  requiredKeys: Array<any>\n): Array<any> => {\n  return requiredKeys.filter(requiredKey => !(requiredKey in object));\n};\n\nexport async function setIsEnabledAsync(value: boolean): Promise<void> {\n  _enabled = value;\n  await NativeModules.ExponentAV.setAudioIsEnabled(value);\n  // TODO : We immediately pause all players when disabled, but we do not resume all shouldPlay\n  // players when enabled. Perhaps for completeness we should allow this; the design of the\n  // enabling API is for people to enable / disable this audio library, but I think that it should\n  // intuitively also double as a global pause/resume.\n}\n\nexport async function setAudioModeAsync(mode: AudioMode): Promise<void> {\n  const missingKeys = _findMissingKeys(mode, [\n    'allowsRecordingIOS',\n    'interruptionModeIOS',\n    'playsInSilentModeIOS',\n    'interruptionModeAndroid',\n    'shouldDuckAndroid',\n  ]);\n  if (missingKeys.length > 0) {\n    throw new Error(\n      `Audio mode attempted to be set without the required keys: ${JSON.stringify(\n        missingKeys\n      )}`\n    );\n  }\n  if (\n    !_isValueValid(mode.interruptionModeIOS, [\n      INTERRUPTION_MODE_IOS_MIX_WITH_OTHERS,\n      INTERRUPTION_MODE_IOS_DO_NOT_MIX,\n      INTERRUPTION_MODE_IOS_DUCK_OTHERS,\n    ])\n  ) {\n    throw new Error(`\"interruptionModeIOS\" was set to an invalid value.`);\n  }\n  if (\n    !_isValueValid(mode.interruptionModeAndroid, [\n      INTERRUPTION_MODE_ANDROID_DO_NOT_MIX,\n      INTERRUPTION_MODE_ANDROID_DUCK_OTHERS,\n    ])\n  ) {\n    throw new Error(`\"interruptionModeAndroid\" was set to an invalid value.`);\n  }\n  if (\n    typeof mode.allowsRecordingIOS !== 'boolean' ||\n    typeof mode.playsInSilentModeIOS !== 'boolean' ||\n    typeof mode.shouldDuckAndroid !== 'boolean'\n  ) {\n    throw new Error(\n      '\"allowsRecordingIOS\", \"playsInSilentModeIOS\", and \"shouldDuckAndroid\" must be booleans.'\n    );\n  }\n  await NativeModules.ExponentAV.setAudioMode(mode);\n}\n\nexport class Sound {\n  _loaded: boolean;\n  _loading: boolean;\n  _key: number;\n  _onPlaybackStatusUpdate: ?(status: PlaybackStatus) => void;\n\n  constructor() {\n    this._loaded = false;\n    this._loading = false;\n    this._key = -1;\n    this._onPlaybackStatusUpdate = null;\n  }\n\n  static create = async (\n    source: PlaybackSource,\n    initialStatus: PlaybackStatusToSet = {},\n    onPlaybackStatusUpdate: ?(status: PlaybackStatus) => void = null,\n    downloadFirst: boolean = true\n  ): Promise<{ sound: Sound, status: PlaybackStatus }> => {\n    const sound: Sound = new Sound();\n    sound.setOnPlaybackStatusUpdate(onPlaybackStatusUpdate);\n    const status: PlaybackStatus = await sound.loadAsync(\n      source,\n      initialStatus,\n      downloadFirst\n    );\n    return { sound, status };\n  };\n\n  // Internal methods\n\n  _callOnPlaybackStatusUpdateForNewStatus(status: PlaybackStatus) {\n    if (this._onPlaybackStatusUpdate != null) {\n      this._onPlaybackStatusUpdate(status);\n    }\n  }\n\n  async _performOperationAndHandleStatusAsync(\n    operation: () => Promise<PlaybackStatus>\n  ): Promise<PlaybackStatus> {\n    if (!_enabled) {\n      throw _DISABLED_ERROR;\n    }\n    if (this._loaded) {\n      const status = await operation();\n      this._callOnPlaybackStatusUpdateForNewStatus(status);\n      return status;\n    } else {\n      throw new Error('Cannot complete operation because sound is not loaded.');\n    }\n  }\n\n  _internalStatusUpdateCallback = (status: PlaybackStatus) => {\n    this._callOnPlaybackStatusUpdateForNewStatus(status);\n    this._setInternalStatusUpdateCallback(); // Callbacks are only called once and then released.\n  };\n\n  // TODO: We can optimize by only using time observer on native if (this._onPlaybackStatusUpdate).\n  _setInternalStatusUpdateCallback() {\n    if (this._loaded) {\n      NativeModules.ExponentAV.setStatusUpdateCallbackForSound(\n        this._key,\n        this._internalStatusUpdateCallback\n      );\n    }\n  }\n\n  _errorCallback = (error: string) => {\n    this._loaded = false;\n    this._key = -1;\n    this._callOnPlaybackStatusUpdateForNewStatus(_getUnloadedStatus(error));\n  };\n\n  // ### Unified playback API ### (consistent with Video.js)\n  // All calls automatically call onPlaybackStatusUpdate as a side effect.\n\n  // Get status API\n\n  getStatusAsync = async (): Promise<PlaybackStatus> => {\n    if (this._loaded) {\n      return this._performOperationAndHandleStatusAsync(() =>\n        NativeModules.ExponentAV.getStatusForSound(this._key)\n      );\n    }\n    const status: PlaybackStatus = _getUnloadedStatus();\n    this._callOnPlaybackStatusUpdateForNewStatus(status);\n    return status;\n  };\n\n  setOnPlaybackStatusUpdate(\n    onPlaybackStatusUpdate: ?(status: PlaybackStatus) => void\n  ) {\n    this._onPlaybackStatusUpdate = onPlaybackStatusUpdate;\n    this.getStatusAsync();\n  }\n\n  // DEPRECATED -- WILL BE REMOVED IN SDK21:\n  setCallback = (callback: ?(status: PlaybackStatus) => void) => {\n    console.warn(\n      `'Sound.setCallback()' is deprecated and will be removed in SDK21. Use 'Sound.setOnPlaybackStatusUpdate()' instead.`\n    );\n    this.setOnPlaybackStatusUpdate(callback);\n  };\n\n  // Loading / unloading API\n\n  async loadAsync(\n    source: PlaybackSource,\n    initialStatus: PlaybackStatusToSet = {},\n    downloadFirst: boolean = true\n  ): Promise<PlaybackStatus> {\n    if (!_enabled) {\n      throw _DISABLED_ERROR;\n    }\n    if (this.loading) {\n      throw new Error('The Sound is already loading.');\n    }\n    if (!this._loaded) {\n      this._loading = true;\n\n      const {\n        uri,\n        fullInitialStatus,\n      } = await _getURIAndFullInitialStatusForLoadAsync(\n        source,\n        initialStatus,\n        downloadFirst\n      );\n\n      // This is a workaround, since using load with resolve / reject seems to not work.\n      return new Promise(\n        function(resolve, reject) {\n          const loadSuccess = (key: number, status: PlaybackStatus) => {\n            this._key = key;\n            this._loaded = true;\n            this._loading = false;\n            NativeModules.ExponentAV.setErrorCallbackForSound(\n              this._key,\n              this._errorCallback\n            );\n            this._setInternalStatusUpdateCallback();\n            this._callOnPlaybackStatusUpdateForNewStatus(status);\n            resolve(status);\n          };\n          const loadError = (error: string) => {\n            this._loading = false;\n            reject(new Error(error));\n          };\n          NativeModules.ExponentAV.loadForSound(\n            uri,\n            fullInitialStatus,\n            loadSuccess,\n            loadError\n          );\n        }.bind(this)\n      );\n    } else {\n      throw new Error('The Sound is already loaded.');\n    }\n  }\n\n  async unloadAsync(): Promise<PlaybackStatus> {\n    if (this._loaded) {\n      this._loaded = false;\n      const key = this._key;\n      this._key = -1;\n      const status = await NativeModules.ExponentAV.unloadForSound(key);\n      this._callOnPlaybackStatusUpdateForNewStatus(status);\n      return status;\n    } else {\n      return this.getStatusAsync(); // Automatically calls onPlaybackStatusUpdate.\n    }\n  }\n\n  // Set status API (only available while isLoaded = true)\n\n  async setStatusAsync(status: PlaybackStatusToSet): Promise<PlaybackStatus> {\n    _throwErrorIfValuesOutOfBoundsInStatus(status);\n    return this._performOperationAndHandleStatusAsync(() =>\n      NativeModules.ExponentAV.setStatusForSound(this._key, status)\n    );\n  }\n\n  // Additional convenience methods on top of setStatusAsync are set via _COMMON_AV_PLAYBACK_METHODS.\n  playAsync: () => Promise<PlaybackStatus>;\n  playFromPositionAsync: (positionMillis: number) => Promise<PlaybackStatus>;\n  pauseAsync: () => Promise<PlaybackStatus>;\n  stopAsync: () => Promise<PlaybackStatus>;\n  setPositionAsync: (positionMillis: number) => Promise<PlaybackStatus>;\n  setRateAsync: (\n    rate: number,\n    shouldCorrectPitch: boolean\n  ) => Promise<PlaybackStatus>;\n  setVolumeAsync: (volume: number) => Promise<PlaybackStatus>;\n  setIsMutedAsync: (isMuted: boolean) => Promise<PlaybackStatus>;\n  setIsLoopingAsync: (isLooping: boolean) => Promise<PlaybackStatus>;\n  setProgressUpdateIntervalAsync: (\n    progressUpdateIntervalMillis: number\n  ) => Promise<PlaybackStatus>;\n}\n\nObject.assign(Sound.prototype, _COMMON_AV_PLAYBACK_METHODS);\n\nexport class Recording {\n  _canRecord: boolean;\n  _isDoneRecording: boolean;\n  _finalDurationMillis: number;\n  _uri: ?string;\n  _onRecordingStatusUpdate: ?(status: RecordingStatus) => void;\n  _progressUpdateTimeoutVariable: ?number;\n  _progressUpdateIntervalMillis: number;\n  _options: ?RecordingOptions;\n\n  constructor() {\n    this._canRecord = false;\n    this._isDoneRecording = false;\n    this._finalDurationMillis = 0;\n    this._uri = null;\n    this._progressUpdateTimeoutVariable = null;\n    this._progressUpdateIntervalMillis = _DEFAULT_PROGRESS_UPDATE_INTERVAL_MILLIS;\n    this._options = null;\n  }\n\n  // Internal methods\n\n  _cleanupForUnloadedRecorder = async (finalStatus: RecordingStatus) => {\n    this._canRecord = false;\n    this._isDoneRecording = true;\n    // $FlowFixMe(greg): durationMillis is not always defined\n    this._finalDurationMillis = finalStatus.durationMillis;\n    _recorderExists = false;\n    if (NativeModules.ExponentAV.setUnloadedCallbackForAndroidRecording) {\n      NativeModules.ExponentAV.setUnloadedCallbackForAndroidRecording(null);\n    }\n    this._disablePolling();\n    return await this.getStatusAsync(); // Automatically calls onRecordingStatusUpdate for the final state.\n  };\n\n  _pollingLoop = async () => {\n    if (_enabled && this._canRecord && this._onRecordingStatusUpdate != null) {\n      this._progressUpdateTimeoutVariable = setTimeout(\n        this._pollingLoop,\n        this._progressUpdateIntervalMillis\n      );\n      try {\n        await this.getStatusAsync();\n      } catch (error) {\n        this._disablePolling();\n      }\n    }\n  };\n\n  _disablePolling() {\n    if (this._progressUpdateTimeoutVariable != null) {\n      clearTimeout(this._progressUpdateTimeoutVariable);\n      this._progressUpdateTimeoutVariable = null;\n    }\n  }\n\n  _enablePollingIfNecessaryAndPossible() {\n    if (_enabled && this._canRecord && this._onRecordingStatusUpdate != null) {\n      this._disablePolling();\n      this._pollingLoop();\n    }\n  }\n\n  _callOnRecordingStatusUpdateForNewStatus(status: RecordingStatus) {\n    if (this._onRecordingStatusUpdate != null) {\n      this._onRecordingStatusUpdate(status);\n    }\n  }\n\n  async _performOperationAndHandleStatusAsync(\n    operation: () => Promise<RecordingStatus>\n  ): Promise<RecordingStatus> {\n    if (!_enabled) {\n      throw _DISABLED_ERROR;\n    }\n    if (this._canRecord) {\n      const status = await operation();\n      this._callOnRecordingStatusUpdateForNewStatus(status);\n      return status;\n    } else {\n      throw new Error(\n        'Cannot complete operation because this recorder is not ready to record.'\n      );\n    }\n  }\n\n  // Note that all calls automatically call onRecordingStatusUpdate as a side effect.\n\n  // Get status API\n\n  getStatusAsync = async (): Promise<RecordingStatus> => {\n    // Automatically calls onRecordingStatusUpdate.\n    if (this._canRecord) {\n      return this._performOperationAndHandleStatusAsync(() =>\n        NativeModules.ExponentAV.getAudioRecordingStatus()\n      );\n    }\n    const status: RecordingStatus = this._isDoneRecording\n      ? {\n          canRecord: false,\n          isDoneRecording: true,\n          durationMillis: this._finalDurationMillis,\n        }\n      : {\n          canRecord: false,\n          isDoneRecording: false,\n        };\n    this._callOnRecordingStatusUpdateForNewStatus(status);\n    return status;\n  };\n\n  setOnRecordingStatusUpdate(\n    onRecordingStatusUpdate: ?(status: RecordingStatus) => void\n  ) {\n    this._onRecordingStatusUpdate = onRecordingStatusUpdate;\n    if (onRecordingStatusUpdate == null) {\n      this._disablePolling();\n    } else {\n      this._enablePollingIfNecessaryAndPossible();\n    }\n    this.getStatusAsync();\n  }\n\n  // DEPRECATED -- WILL BE REMOVED IN SDK21:\n  setCallback(callback: ?(status: RecordingStatus) => void) {\n    // DEPRECATED -- WILL BE REMOVED IN SDK21:\n    console.warn(\n      `'Recording.setCallback()' is deprecated and will be removed in SDK21. Use 'Recording.setOnRecordingStatusUpdate()' instead.`\n    );\n    this.setOnRecordingStatusUpdate(callback);\n  }\n\n  setProgressUpdateInterval(progressUpdateIntervalMillis: number) {\n    this._progressUpdateIntervalMillis = progressUpdateIntervalMillis;\n    this.getStatusAsync();\n  }\n\n  // Record API\n\n  async prepareToRecordAsync(\n    options: RecordingOptions = RECORDING_OPTIONS_PRESET_LOW_QUALITY\n  ): Promise<RecordingStatus> {\n    if (!_enabled) {\n      throw _DISABLED_ERROR;\n    }\n\n    if (_recorderExists) {\n      throw new Error(\n        'Only one Recording object can be prepared at a given time.'\n      );\n    }\n\n    if (this._isDoneRecording) {\n      throw new Error(\n        'This Recording object is done recording; you must make a new one.'\n      );\n    }\n\n    if (!options || !options.android || !options.ios) {\n      throw new Error(\n        'You must provide recording options for android and ios in order to prepare to record.'\n      );\n    }\n\n    const extensionRegex = /^\\.\\w+$/;\n    if (\n      !options.android.extension ||\n      !options.ios.extension ||\n      !extensionRegex.test(options.android.extension) ||\n      !extensionRegex.test(options.ios.extension)\n    ) {\n      throw new Error(\n        `Your file extensions must match ${extensionRegex.toString()}.`\n      );\n    }\n\n    if (!this._canRecord) {\n      if (NativeModules.ExponentAV.setUnloadedCallbackForAndroidRecording) {\n        NativeModules.ExponentAV.setUnloadedCallbackForAndroidRecording(\n          this._cleanupForUnloadedRecorder\n        );\n      }\n\n      const {\n        uri,\n        status,\n      }: {\n        uri: string,\n        status: Object, // status is of type RecordingStatus, but without the canRecord field populated.\n      } = await NativeModules.ExponentAV.prepareAudioRecorder(options);\n      _recorderExists = true;\n      this._uri = uri;\n      this._options = options;\n      this._canRecord = true;\n      this._callOnRecordingStatusUpdateForNewStatus(status);\n      this._enablePollingIfNecessaryAndPossible();\n      return status;\n    } else {\n      throw new Error('This Recording object is already prepared to record.');\n    }\n  }\n\n  async startAsync(): Promise<RecordingStatus> {\n    return this._performOperationAndHandleStatusAsync(() =>\n      NativeModules.ExponentAV.startAudioRecording()\n    );\n  }\n\n  async pauseAsync(): Promise<RecordingStatus> {\n    return this._performOperationAndHandleStatusAsync(() =>\n      NativeModules.ExponentAV.pauseAudioRecording()\n    );\n  }\n\n  async stopAndUnloadAsync(): Promise<RecordingStatus> {\n    if (!this._canRecord) {\n      if (this._isDoneRecording) {\n        throw new Error(\n          'Cannot unload a Recording that has already been unloaded.'\n        );\n      } else {\n        throw new Error(\n          'Cannot unload a Recording that has not been prepared.'\n        );\n      }\n    }\n    // We perform a separate native API call so that the state of the Recording can be updated with\n    // the final duration of the recording. (We cast stopStatus as Object to appease Flow)\n    const finalStatus: Object = await NativeModules.ExponentAV.stopAudioRecording();\n    await NativeModules.ExponentAV.unloadAudioRecorder();\n    return this._cleanupForUnloadedRecorder(finalStatus);\n  }\n\n  // Read API\n\n  getURI(): ?string {\n    return this._uri;\n  }\n\n  async createNewLoadedSound(\n    initialStatus: PlaybackStatusToSet = {},\n    onPlaybackStatusUpdate: ?(status: PlaybackStatus) => void = null\n  ): Promise<{ sound: Sound, status: PlaybackStatus }> {\n    if (this._uri == null || !this._isDoneRecording) {\n      throw new Error(\n        'Cannot create sound when the Recording has not finished!'\n      );\n    }\n    return Sound.create(\n      // $FlowFixMe: Flow can't distinguish between this literal and Asset\n      { uri: this._uri },\n      initialStatus,\n      onPlaybackStatusUpdate,\n      false\n    );\n  }\n}\n"]}]