["829ca55e20a817dc1e1093e29b5ada165a065cca","4c6a93b289a03455e1e4b58a85696f7f3403c8b3",["Platform","Systrace","fbjs/lib/invariant","NativeModules","fbjs/lib/performanceNow","parseErrorStack","fbjs/lib/warning"],[39,75,113,160,321,1510,1779],{"version":3,"sources":["/Users/mani/Documents/Udacity/Core/React_Native/UdaciFitness/node_modules/react-native/Libraries/Core/Timers/JSTimers.js"],"names":["Platform","require","Systrace","invariant","Timing","_performanceNow","performanceNow","FRAME_DURATION","IDLE_CALLBACK_FRAME_DEADLINE","MAX_TIMER_DURATION_MS","IS_ANDROID","OS","ANDROID_LONG_TIMER_MESSAGE","callbacks","types","timerIDs","immediates","requestIdleCallbacks","requestIdleCallbackTimeouts","identifiers","GUID","errors","hasEmittedTimeDriftWarning","_getFreeIndex","freeIndex","indexOf","length","_allocateCallback","func","type","id","__DEV__","parseErrorStack","error","Error","framesToPop","stack","shift","_callTimer","timerID","frameTime","didTimeout","timerIndex","callback","console","identifier","beginEvent","methodName","_clearIndex","timeRemaining","Math","max","e","push","endEvent","_callImmediatesPass","passImmediates","slice","i","_freeCallback","index","deleteTimer","JSTimers","setTimeout","duration","args","warn","apply","undefined","createTimer","Date","now","setInterval","setImmediate","requestAnimationFrame","requestIdleCallback","options","setSendIdleEvents","timeout","timeoutId","clearTimeout","deadline","splice","cancelIdleCallback","clearInterval","clearImmediate","cancelAnimationFrame","callTimers","timersToCall","errorCount","ii","bind","callIdleCallbacks","passIdleCallbacks","forEach","callImmediates","emitTimeDriftWarning","warningMessage","module","exports"],"mappings":"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","sourcesContent":["/**\n * Copyright (c) 2015-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule JSTimers\n * @format\n * @flow\n */\n'use strict';\n\nconst Platform = require('Platform');\nconst Systrace = require('Systrace');\n\nconst invariant = require('fbjs/lib/invariant');\nconst {Timing} = require('NativeModules');\n\nimport type {ExtendedError} from 'parseErrorStack';\n\nlet _performanceNow = null;\nfunction performanceNow() {\n  if (!_performanceNow) {\n    _performanceNow = require('fbjs/lib/performanceNow');\n  }\n  return _performanceNow();\n}\n\n/**\n * JS implementation of timer functions. Must be completely driven by an\n * external clock signal, all that's stored here is timerID, timer type, and\n * callback.\n */\n\nexport type JSTimerType =\n  | 'setTimeout'\n  | 'setInterval'\n  | 'requestAnimationFrame'\n  | 'setImmediate'\n  | 'requestIdleCallback';\n\n// These timing contants should be kept in sync with the ones in native ios and\n// android `RCTTiming` module.\nconst FRAME_DURATION = 1000 / 60;\nconst IDLE_CALLBACK_FRAME_DEADLINE = 1;\n\nconst MAX_TIMER_DURATION_MS = 60 * 1000;\nconst IS_ANDROID = Platform.OS === 'android';\nconst ANDROID_LONG_TIMER_MESSAGE =\n  'Setting a timer for a long period of time, i.e. multiple minutes, is a ' +\n  'performance and correctness issue on Android as it keeps the timer ' +\n  'module awake, and timers can only be called when the app is in the foreground. ' +\n  'See https://github.com/facebook/react-native/issues/12981 for more info.';\n\n// Parallel arrays\nconst callbacks: Array<?Function> = [];\nconst types: Array<?JSTimerType> = [];\nconst timerIDs: Array<?number> = [];\nlet immediates: Array<number> = [];\nlet requestIdleCallbacks: Array<number> = [];\nconst requestIdleCallbackTimeouts: {[number]: number} = {};\nconst identifiers: Array<null | {methodName: string}> = [];\n\nlet GUID = 1;\nlet errors: ?Array<Error> = null;\n\nlet hasEmittedTimeDriftWarning = false;\n\n// Returns a free index if one is available, and the next consecutive index otherwise.\nfunction _getFreeIndex(): number {\n  let freeIndex = timerIDs.indexOf(null);\n  if (freeIndex === -1) {\n    freeIndex = timerIDs.length;\n  }\n  return freeIndex;\n}\n\nfunction _allocateCallback(func: Function, type: JSTimerType): number {\n  const id = GUID++;\n  const freeIndex = _getFreeIndex();\n  timerIDs[freeIndex] = id;\n  callbacks[freeIndex] = func;\n  types[freeIndex] = type;\n  if (__DEV__) {\n    const parseErrorStack = require('parseErrorStack');\n    const error: ExtendedError = new Error();\n    error.framesToPop = 1;\n    const stack = parseErrorStack(error);\n    if (stack) {\n      identifiers[freeIndex] = stack.shift();\n    }\n  }\n  return id;\n}\n\n/**\n * Calls the callback associated with the ID. Also unregister that callback\n * if it was a one time timer (setTimeout), and not unregister it if it was\n * recurring (setInterval).\n */\nfunction _callTimer(timerID: number, frameTime: number, didTimeout: ?boolean) {\n  require('fbjs/lib/warning')(\n    timerID <= GUID,\n    'Tried to call timer with ID %s but no such timer exists.',\n    timerID,\n  );\n\n  // timerIndex of -1 means that no timer with that ID exists. There are\n  // two situations when this happens, when a garbage timer ID was given\n  // and when a previously existing timer was deleted before this callback\n  // fired. In both cases we want to ignore the timer id, but in the former\n  // case we warn as well.\n  const timerIndex = timerIDs.indexOf(timerID);\n  if (timerIndex === -1) {\n    return;\n  }\n\n  const type = types[timerIndex];\n  const callback = callbacks[timerIndex];\n  if (!callback || !type) {\n    console.error('No callback found for timerID ' + timerID);\n    return;\n  }\n\n  if (__DEV__) {\n    const identifier = identifiers[timerIndex] || {};\n    Systrace.beginEvent('Systrace.callTimer: ' + identifier.methodName);\n  }\n\n  // Clear the metadata\n  if (\n    type === 'setTimeout' ||\n    type === 'setImmediate' ||\n    type === 'requestAnimationFrame' ||\n    type === 'requestIdleCallback'\n  ) {\n    _clearIndex(timerIndex);\n  }\n\n  try {\n    if (\n      type === 'setTimeout' ||\n      type === 'setInterval' ||\n      type === 'setImmediate'\n    ) {\n      callback();\n    } else if (type === 'requestAnimationFrame') {\n      callback(performanceNow());\n    } else if (type === 'requestIdleCallback') {\n      callback({\n        timeRemaining: function() {\n          // TODO: Optimisation: allow running for longer than one frame if\n          // there are no pending JS calls on the bridge from native. This\n          // would require a way to check the bridge queue synchronously.\n          return Math.max(0, FRAME_DURATION - (performanceNow() - frameTime));\n        },\n        didTimeout: !!didTimeout,\n      });\n    } else {\n      console.error('Tried to call a callback with invalid type: ' + type);\n    }\n  } catch (e) {\n    // Don't rethrow so that we can run all timers.\n    if (!errors) {\n      errors = [e];\n    } else {\n      errors.push(e);\n    }\n  }\n\n  if (__DEV__) {\n    Systrace.endEvent();\n  }\n}\n\n/**\n * Performs a single pass over the enqueued immediates. Returns whether\n * more immediates are queued up (can be used as a condition a while loop).\n */\nfunction _callImmediatesPass() {\n  if (__DEV__) {\n    Systrace.beginEvent('callImmediatesPass()');\n  }\n\n  // The main reason to extract a single pass is so that we can track\n  // in the system trace\n  if (immediates.length > 0) {\n    const passImmediates = immediates.slice();\n    immediates = [];\n\n    // Use for loop rather than forEach as per @vjeux's advice\n    // https://github.com/facebook/react-native/commit/c8fd9f7588ad02d2293cac7224715f4af7b0f352#commitcomment-14570051\n    for (let i = 0; i < passImmediates.length; ++i) {\n      _callTimer(passImmediates[i], 0);\n    }\n  }\n\n  if (__DEV__) {\n    Systrace.endEvent();\n  }\n  return immediates.length > 0;\n}\n\nfunction _clearIndex(i: number) {\n  timerIDs[i] = null;\n  callbacks[i] = null;\n  types[i] = null;\n  identifiers[i] = null;\n}\n\nfunction _freeCallback(timerID: number) {\n  // timerIDs contains nulls after timers have been removed;\n  // ignore nulls upfront so indexOf doesn't find them\n  if (timerID == null) {\n    return;\n  }\n\n  const index = timerIDs.indexOf(timerID);\n  // See corresponding comment in `callTimers` for reasoning behind this\n  if (index !== -1) {\n    _clearIndex(index);\n    const type = types[index];\n    if (type !== 'setImmediate' && type !== 'requestIdleCallback') {\n      Timing.deleteTimer(timerID);\n    }\n  }\n}\n\n/**\n * JS implementation of timer functions. Must be completely driven by an\n * external clock signal, all that's stored here is timerID, timer type, and\n * callback.\n */\nconst JSTimers = {\n  /**\n   * @param {function} func Callback to be invoked after `duration` ms.\n   * @param {number} duration Number of milliseconds.\n   */\n  setTimeout: function(\n    func: Function,\n    duration: number,\n    ...args?: any\n  ): number {\n    if (__DEV__ && IS_ANDROID && duration > MAX_TIMER_DURATION_MS) {\n      console.warn(\n        ANDROID_LONG_TIMER_MESSAGE +\n          '\\n' +\n          '(Saw setTimeout with duration ' +\n          duration +\n          'ms)',\n      );\n    }\n    const id = _allocateCallback(\n      () => func.apply(undefined, args),\n      'setTimeout',\n    );\n    Timing.createTimer(id, duration || 0, Date.now(), /* recurring */ false);\n    return id;\n  },\n\n  /**\n   * @param {function} func Callback to be invoked every `duration` ms.\n   * @param {number} duration Number of milliseconds.\n   */\n  setInterval: function(\n    func: Function,\n    duration: number,\n    ...args?: any\n  ): number {\n    if (__DEV__ && IS_ANDROID && duration > MAX_TIMER_DURATION_MS) {\n      console.warn(\n        ANDROID_LONG_TIMER_MESSAGE +\n          '\\n' +\n          '(Saw setInterval with duration ' +\n          duration +\n          'ms)',\n      );\n    }\n    const id = _allocateCallback(\n      () => func.apply(undefined, args),\n      'setInterval',\n    );\n    Timing.createTimer(id, duration || 0, Date.now(), /* recurring */ true);\n    return id;\n  },\n\n  /**\n   * @param {function} func Callback to be invoked before the end of the\n   * current JavaScript execution loop.\n   */\n  setImmediate: function(func: Function, ...args?: any) {\n    const id = _allocateCallback(\n      () => func.apply(undefined, args),\n      'setImmediate',\n    );\n    immediates.push(id);\n    return id;\n  },\n\n  /**\n   * @param {function} func Callback to be invoked every frame.\n   */\n  requestAnimationFrame: function(func: Function) {\n    const id = _allocateCallback(func, 'requestAnimationFrame');\n    Timing.createTimer(id, 1, Date.now(), /* recurring */ false);\n    return id;\n  },\n\n  /**\n   * @param {function} func Callback to be invoked every frame and provided\n   * with time remaining in frame.\n   * @param {?object} options\n   */\n  requestIdleCallback: function(func: Function, options: ?Object) {\n    if (requestIdleCallbacks.length === 0) {\n      Timing.setSendIdleEvents(true);\n    }\n\n    const timeout = options && options.timeout;\n    const id = _allocateCallback(\n      timeout != null\n        ? deadline => {\n            const timeoutId = requestIdleCallbackTimeouts[id];\n            if (timeoutId) {\n              JSTimers.clearTimeout(timeoutId);\n              requestIdleCallbackTimeouts[id];\n            }\n            return func(deadline);\n          }\n        : func,\n      'requestIdleCallback',\n    );\n    requestIdleCallbacks.push(id);\n\n    if (timeout != null) {\n      const timeoutId = JSTimers.setTimeout(() => {\n        const index = requestIdleCallbacks.indexOf(id);\n        if (index > -1) {\n          requestIdleCallbacks.splice(index, 1);\n          _callTimer(id, performanceNow(), true);\n        }\n        delete requestIdleCallbackTimeouts[id];\n        if (requestIdleCallbacks.length === 0) {\n          Timing.setSendIdleEvents(false);\n        }\n      }, timeout);\n      requestIdleCallbackTimeouts[id] = timeoutId;\n    }\n    return id;\n  },\n\n  cancelIdleCallback: function(timerID: number) {\n    _freeCallback(timerID);\n    const index = requestIdleCallbacks.indexOf(timerID);\n    if (index !== -1) {\n      requestIdleCallbacks.splice(index, 1);\n    }\n\n    const timeoutId = requestIdleCallbackTimeouts[timerID];\n    if (timeoutId) {\n      JSTimers.clearTimeout(timeoutId);\n      delete requestIdleCallbackTimeouts[timerID];\n    }\n\n    if (requestIdleCallbacks.length === 0) {\n      Timing.setSendIdleEvents(false);\n    }\n  },\n\n  clearTimeout: function(timerID: number) {\n    _freeCallback(timerID);\n  },\n\n  clearInterval: function(timerID: number) {\n    _freeCallback(timerID);\n  },\n\n  clearImmediate: function(timerID: number) {\n    _freeCallback(timerID);\n    const index = immediates.indexOf(timerID);\n    if (index !== -1) {\n      immediates.splice(index, 1);\n    }\n  },\n\n  cancelAnimationFrame: function(timerID: number) {\n    _freeCallback(timerID);\n  },\n\n  /**\n   * This is called from the native side. We are passed an array of timerIDs,\n   * and\n   */\n  callTimers: function(timersToCall: Array<number>) {\n    invariant(\n      timersToCall.length !== 0,\n      'Cannot call `callTimers` with an empty list of IDs.',\n    );\n\n    // $FlowFixMe: optionals do not allow assignment from null\n    errors = null;\n    for (let i = 0; i < timersToCall.length; i++) {\n      _callTimer(timersToCall[i], 0);\n    }\n\n    if (errors) {\n      const errorCount = errors.length;\n      if (errorCount > 1) {\n        // Throw all the other errors in a setTimeout, which will throw each\n        // error one at a time\n        for (let ii = 1; ii < errorCount; ii++) {\n          JSTimers.setTimeout(\n            (error => {\n              throw error;\n            }).bind(null, errors[ii]),\n            0,\n          );\n        }\n      }\n      throw errors[0];\n    }\n  },\n\n  callIdleCallbacks: function(frameTime: number) {\n    if (\n      FRAME_DURATION - (performanceNow() - frameTime) <\n      IDLE_CALLBACK_FRAME_DEADLINE\n    ) {\n      return;\n    }\n\n    // $FlowFixMe: optionals do not allow assignment from null\n    errors = null;\n    if (requestIdleCallbacks.length > 0) {\n      const passIdleCallbacks = requestIdleCallbacks.slice();\n      requestIdleCallbacks = [];\n\n      for (let i = 0; i < passIdleCallbacks.length; ++i) {\n        _callTimer(passIdleCallbacks[i], frameTime);\n      }\n    }\n\n    if (requestIdleCallbacks.length === 0) {\n      Timing.setSendIdleEvents(false);\n    }\n\n    if (errors) {\n      errors.forEach(error =>\n        JSTimers.setTimeout(() => {\n          throw error;\n        }, 0),\n      );\n    }\n  },\n\n  /**\n   * This is called after we execute any command we receive from native but\n   * before we hand control back to native.\n   */\n  callImmediates() {\n    errors = null;\n    while (_callImmediatesPass()) {}\n    if (errors) {\n      errors.forEach(error =>\n        JSTimers.setTimeout(() => {\n          throw error;\n        }, 0),\n      );\n    }\n  },\n\n  /**\n   * Called from native (in development) when environment times are out-of-sync.\n   */\n  emitTimeDriftWarning(warningMessage: string) {\n    if (hasEmittedTimeDriftWarning) {\n      return;\n    }\n    hasEmittedTimeDriftWarning = true;\n    console.warn(warningMessage);\n  },\n};\n\nif (!Timing) {\n  console.warn(\"Timing native module is not available, can't set timers.\");\n  // $FlowFixMe: we can assume timers are generally available\n  module.exports = ({\n    callImmediates: JSTimers.callImmediates,\n    setImmediate: JSTimers.setImmediate,\n  }: typeof JSTimers);\n} else {\n  module.exports = JSTimers;\n}\n"]}]